{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u2691 The wiki is built with MkDocs and GitHub Pages. It supports inline PlantUML diagrams. Inspired by wiki.nikitavoloboev.xyz & The Blue Book . Workflow \u2691 For editing the wiki I currently use Obsidian . After commit & push the new page will be created and published trough GitHub Actions. An detailed explanation how that works can you find here . Using the wiki \u2691 You can quickly search the contents of this wiki above or you can explore the tree view to the left.","title":"Introduction"},{"location":"#introduction","text":"The wiki is built with MkDocs and GitHub Pages. It supports inline PlantUML diagrams. Inspired by wiki.nikitavoloboev.xyz & The Blue Book .","title":"Introduction"},{"location":"#workflow","text":"For editing the wiki I currently use Obsidian . After commit & push the new page will be created and published trough GitHub Actions. An detailed explanation how that works can you find here .","title":"Workflow"},{"location":"#using-the-wiki","text":"You can quickly search the contents of this wiki above or you can explore the tree view to the left.","title":"Using the wiki"},{"location":"Blog/Misc/blog-gh-pages-mkdocs/","text":"How to create a blog with GitHub Pages and MkDocs \u2691 Dockerfile \u2691 Create the Containerfile at Dockerfile or Containerfile . FROM docker.io/ubuntu:focal RUN : \\ && apt-get update -y \\ && apt-get install -y --no-install-recommends \\ python3 \\ python3-venv \\ python3-pip \\ && rm -rf /var/lib/api/lists* WORKDIR /src COPY requirements.txt . ENV PATH = /venv/bin: $PATH RUN : \\ && python3 -m venv /venv \\ && python3 -m pip --no-cache-dir install -r requirements.txt COPY . . WORKDIR /src/blog Taskfile \u2691 To store some reoccuring tasks we use a Taskfile. To install Task use this link or just use sudo sh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin Create the Taskfile.yml . # https://taskfile.dev version : \"3\" vars : CONTAINER_NAME : blog.rwxd.eu CURRENT_DIR : sh : pwd SITE_DIR : \"{{.CURRENT_DIR}}/docs/site\" tasks : default : cmds : - task -l silent : true setup : desc : Setup requirements cmds : - python3 -m pip install -r requirements.txt -q - pre-commit install silent : true image : desc : builds container image with name blog.rwxd.eu cmds : - podman build -t {{.CONTAINER_NAME}} -f ./Containerfile silent : true serve : desc : Serve blog with a container vars : PORT : 8000 MOUNT : \"{{.CURRENT_DIR}}/src\" cmds : - task : image - podman run --rm -p {{.PORT}}:8000 -v ./:/src {{.CONTAINER_NAME}} mkdocs serve silent : true serve-local : desc : Serve blog local dir : ./blog cmds : - mkdocs serve silent : true build : desc : Build blog pages cmds : - task : image - mkdir -p {{.SITE_DIR}} - podman run --rm -v {{.SITE_DIR}}:/src/blog/site {{.CONTAINER_NAME}} sh -c \"mkdocs build\"","title":"How to create a blog with GitHub Pages and MkDocs"},{"location":"Blog/Misc/blog-gh-pages-mkdocs/#how-to-create-a-blog-with-github-pages-and-mkdocs","text":"","title":"How to create a blog with GitHub Pages and MkDocs"},{"location":"Blog/Misc/blog-gh-pages-mkdocs/#dockerfile","text":"Create the Containerfile at Dockerfile or Containerfile . FROM docker.io/ubuntu:focal RUN : \\ && apt-get update -y \\ && apt-get install -y --no-install-recommends \\ python3 \\ python3-venv \\ python3-pip \\ && rm -rf /var/lib/api/lists* WORKDIR /src COPY requirements.txt . ENV PATH = /venv/bin: $PATH RUN : \\ && python3 -m venv /venv \\ && python3 -m pip --no-cache-dir install -r requirements.txt COPY . . WORKDIR /src/blog","title":"Dockerfile"},{"location":"Blog/Misc/blog-gh-pages-mkdocs/#taskfile","text":"To store some reoccuring tasks we use a Taskfile. To install Task use this link or just use sudo sh -c \"$(curl --location https://taskfile.dev/install.sh)\" -- -d -b /usr/local/bin Create the Taskfile.yml . # https://taskfile.dev version : \"3\" vars : CONTAINER_NAME : blog.rwxd.eu CURRENT_DIR : sh : pwd SITE_DIR : \"{{.CURRENT_DIR}}/docs/site\" tasks : default : cmds : - task -l silent : true setup : desc : Setup requirements cmds : - python3 -m pip install -r requirements.txt -q - pre-commit install silent : true image : desc : builds container image with name blog.rwxd.eu cmds : - podman build -t {{.CONTAINER_NAME}} -f ./Containerfile silent : true serve : desc : Serve blog with a container vars : PORT : 8000 MOUNT : \"{{.CURRENT_DIR}}/src\" cmds : - task : image - podman run --rm -p {{.PORT}}:8000 -v ./:/src {{.CONTAINER_NAME}} mkdocs serve silent : true serve-local : desc : Serve blog local dir : ./blog cmds : - mkdocs serve silent : true build : desc : Build blog pages cmds : - task : image - mkdir -p {{.SITE_DIR}} - podman run --rm -v {{.SITE_DIR}}:/src/blog/site {{.CONTAINER_NAME}} sh -c \"mkdocs build\"","title":"Taskfile"},{"location":"Blog/Misc/pluralsight_trial/","text":"Pluralsight demo / trial \u2691 Create a new Pluralsight Account with a one month demo trough Visual Studio Dev Essentials. Create a new Microsoft account with a Microsoft live email Activate PluralSight benefits Confirm the registration email","title":"Pluralsight demo / trial"},{"location":"Blog/Misc/pluralsight_trial/#pluralsight-demo-trial","text":"Create a new Pluralsight Account with a one month demo trough Visual Studio Dev Essentials. Create a new Microsoft account with a Microsoft live email Activate PluralSight benefits Confirm the registration email","title":"Pluralsight demo / trial"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Control%20Plane/","text":"NSX-T Control Plane \u2691 The control plane is responsible for calculating the \"run-time state\" of the systems based on the configuration provided by the NSX-T Manager (management plane). It also communicates with the data plane and therefore is responsible for distributing topology information and pushing stateless configuration information to the forwarding engines. CCP (Central Control Plane) \u2691 The CCP employs cluster of VMs called CCP nodes. The cluster provides redundancy and scalability. User traffic does not traverse the CCP cluster. LCP (Local Control Plane) \u2691 The LCP is found on the transport nodes which use the LCP to connect and communicate with the CCP. The programming for the forwarding entries occurs here.","title":"NSX-T Control Plane"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Control%20Plane/#nsx-t-control-plane","text":"The control plane is responsible for calculating the \"run-time state\" of the systems based on the configuration provided by the NSX-T Manager (management plane). It also communicates with the data plane and therefore is responsible for distributing topology information and pushing stateless configuration information to the forwarding engines.","title":"NSX-T Control Plane"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Control%20Plane/#ccp-central-control-plane","text":"The CCP employs cluster of VMs called CCP nodes. The cluster provides redundancy and scalability. User traffic does not traverse the CCP cluster.","title":"CCP (Central Control Plane)"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Control%20Plane/#lcp-local-control-plane","text":"The LCP is found on the transport nodes which use the LCP to connect and communicate with the CCP. The programming for the forwarding entries occurs here.","title":"LCP (Local Control Plane)"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/","text":"NSX-T Data Plane \u2691 The data plane is where all stateless forwarding takes place based on tables created by the control plane. Packet level stats are found here as well as topology information which is then reported from the data plane up to the control plane. In the data plane are the NSX-T transport nodes which are hosts running the LCP daemons and forwarding engines. N-VDS (NSX Virtual Distributed Switch) \u2691 N-VDS is a basic software-defined switch platform that is completely hypervisor independent. It is responsible for forwarding network traffic between the components on the transport node (virtual machines) or between the internal components and the underlying physical network. The N-VDS is required when implementing an overlay in NSX-T and can therefore co-exist with a VDS (Virtual Distributed Switch) The N-VDS must have at least one or more physical network interfaces (aka pNIC). The N-VDS cannot share a pNIC with another N-VDS. So when you assign a pNIC to a N-VDS it stays with that N-VDS. Several N-VDS can co-exist provided each N-VDS is using it's own set of pNIC(s). Uplinks & pNICs \u2691 A pNIC is the actual physical network port on a transport node and an uplink is used in software on the N-VDS to define how the pNIC will be used. Uplink Profiles \u2691 Uplink Profiles are used as a \"template\" to define how an N-VDS will connect to the physical network and ensures the profile is applied consistently across multiple transport nodes (ESXi or KVM hypervisors). Teaming Policy \u2691 The teaming policy defines how the NSX virtual switch uses its uplinks for redundancy and traffic load balancing. It only defines how the NSX virtual switch balances traffic across its uplinks. Failover Order \u2691 An active uplink is specified along with an optional list of standby uplinks. Should the active uplink fail, the next available uplink in the standby list takes its place immediately. Load Balanced Source Port / Load Balance Source Mac Address \u2691 Traffic is distributed across a specified list of active uplinks. Load Balanced Source Port \u2691 The \"Load Balanced Source Port\" policy maps a virtual interface to an uplink of the host. Traffic sent by this virtual interface will leave the host thorough this uplink only, and traffic destined to this virtual interface will necessarily enter the host via this uplink. Load Balanced Source MAC Address \u2691 The \u201cLoad Balanced Source Mac Address\u201d goes a little bit further in term of granularity for virtual interfaces that can source traffic from different mac addresses: two frames sent by the same virtual interface could be pinned to different host uplinks based on their source mac address. Edge Nodes \u2691 Edge Nodes are \"service appliances\" which are dedicated to running network services that are not dispersed to the hypervisors (ESXi or KVM). They represent a pool of capacity and can be grouped in one cluster or across several clusters. Hypervisor Transport Nodes \u2691 Hypervisor Transport Nodes are simply hypervisors (ESXi or KVM) that have been prepared and configured to run on NSX-T. L2 Bridge \u2691 L2 Bridge is a virtual appliance that is used to bridge traffic between an NSX-T overlay and a traditional VLAN backed physical network. This bridge is deployed through a cluster of two ESXi hosts dedicated for bridging purposes (active/standby on a per-VLAN basis).","title":"NSX-T Data Plane"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#nsx-t-data-plane","text":"The data plane is where all stateless forwarding takes place based on tables created by the control plane. Packet level stats are found here as well as topology information which is then reported from the data plane up to the control plane. In the data plane are the NSX-T transport nodes which are hosts running the LCP daemons and forwarding engines.","title":"NSX-T Data Plane"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#n-vds-nsx-virtual-distributed-switch","text":"N-VDS is a basic software-defined switch platform that is completely hypervisor independent. It is responsible for forwarding network traffic between the components on the transport node (virtual machines) or between the internal components and the underlying physical network. The N-VDS is required when implementing an overlay in NSX-T and can therefore co-exist with a VDS (Virtual Distributed Switch) The N-VDS must have at least one or more physical network interfaces (aka pNIC). The N-VDS cannot share a pNIC with another N-VDS. So when you assign a pNIC to a N-VDS it stays with that N-VDS. Several N-VDS can co-exist provided each N-VDS is using it's own set of pNIC(s).","title":"N-VDS (NSX Virtual Distributed Switch)"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#uplinks-pnics","text":"A pNIC is the actual physical network port on a transport node and an uplink is used in software on the N-VDS to define how the pNIC will be used.","title":"Uplinks &amp; pNICs"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#uplink-profiles","text":"Uplink Profiles are used as a \"template\" to define how an N-VDS will connect to the physical network and ensures the profile is applied consistently across multiple transport nodes (ESXi or KVM hypervisors).","title":"Uplink Profiles"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#teaming-policy","text":"The teaming policy defines how the NSX virtual switch uses its uplinks for redundancy and traffic load balancing. It only defines how the NSX virtual switch balances traffic across its uplinks.","title":"Teaming Policy"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#failover-order","text":"An active uplink is specified along with an optional list of standby uplinks. Should the active uplink fail, the next available uplink in the standby list takes its place immediately.","title":"Failover Order"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#load-balanced-source-port-load-balance-source-mac-address","text":"Traffic is distributed across a specified list of active uplinks.","title":"Load Balanced Source Port / Load Balance Source Mac Address"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#load-balanced-source-port","text":"The \"Load Balanced Source Port\" policy maps a virtual interface to an uplink of the host. Traffic sent by this virtual interface will leave the host thorough this uplink only, and traffic destined to this virtual interface will necessarily enter the host via this uplink.","title":"Load Balanced Source Port"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#load-balanced-source-mac-address","text":"The \u201cLoad Balanced Source Mac Address\u201d goes a little bit further in term of granularity for virtual interfaces that can source traffic from different mac addresses: two frames sent by the same virtual interface could be pinned to different host uplinks based on their source mac address.","title":"Load Balanced Source MAC Address"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#edge-nodes","text":"Edge Nodes are \"service appliances\" which are dedicated to running network services that are not dispersed to the hypervisors (ESXi or KVM). They represent a pool of capacity and can be grouped in one cluster or across several clusters.","title":"Edge Nodes"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#hypervisor-transport-nodes","text":"Hypervisor Transport Nodes are simply hypervisors (ESXi or KVM) that have been prepared and configured to run on NSX-T.","title":"Hypervisor Transport Nodes"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Data%20Plane/#l2-bridge","text":"L2 Bridge is a virtual appliance that is used to bridge traffic between an NSX-T overlay and a traditional VLAN backed physical network. This bridge is deployed through a cluster of two ESXi hosts dedicated for bridging purposes (active/standby on a per-VLAN basis).","title":"L2 Bridge"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Edge%20Technology/","text":"NSX-T Edge Technology \u2691 Edge Nodes are simply \u2018service appliances\u2019 that provide pools of capacity and are reserved to running network services that are not distributed down to the hypervisors. They provide the physical network uplinks (pNICs) that connect to the physical network (underlay). NSX-T provides two types of Edge Nodes: bare metal edge and VM edge. Edge Clusters are a group of Edge Transport nodes that provide a scalable, high-throughput and highly available (redundant) gateway for logical networks created in NSX-T. More on clusters in a minute. Bare Metal Edge vs VM Edge \u2691 Deployment \u2691 Bare metal edge nodes are deployed on a physical server and deployed via ISO or PXE boot. The NICs on the bare metal edge requires support for DPDK (reference the compatibility guide for more information). VM edge node is deployed using OVA/OVF or ISO file and only supported on an ESXi host (not KVM). Performance \u2691 Bare Metal Edge provides sub-second convergence, rapid fail over and higher throughput with low packet size. dedicated interface (NIC) for management (secondary interface can be used for management HA and can also be 1 Gbps). This management network cannot run on a Fast Path interface. Supports a maximum of 16 physical network uplinks for both overlay and external traffic; pNICs connected to ToR switching. Supports in-band management (Fast Path) meaning the management traffic can utilize an interface used by overlay or external network traffic (N-S traffic). Each pNIC (16) has an internal interface that is assigned to the DPDK (Data Plane Development Kit) Fast Path. There is flexibility when assigning the \"Fast Path interfaces\" to overlay or VLAN backed connectivity. Fast Path NICs \u2013 up to four dedicated to the data path using DPDK for high performance; external networks and the overlay use these NICs. The Edge VM contains four internal interfaces (vNICs). Management is reserved on \"eth0\" whereas DPDK Fast Path is assigned to interfaces \"fp-eth0, fp-eth1 and fp-eth2\" which are assigned to external connectivity for NSX-T overlay traffic (TEP traffic) and ToR switching. One vNIC for management. One vNIC for overlay traffic. Two vNICs for external traffic. Edge Clusters \u2691 An Edge Cluster is simply a group of Edge transport nodes. Scale out capabilities for logical networks to the Edge nodes is accomplished via ECMP (Equal Cost Multi-Pathing). Tier-0 and Tier-1 gateways can be hosted on the same Edge Cluster or separate Edge Clusters. Scale out capabilities for logical networks to the Edge nodes is accomplished via ECMP (Equal Cost Multi-Pathing). Tier-0 and Tier-1 gateways can be hosted on the same Edge Cluster or separate Edge Clusters. Dependent upon the requirements for your network design, the Edge cluster could be \"dedicated\" to providing centralized such as NAT. Below is a list of some requirements / limitations on the Edge Clusters: There is a maximum of ten edge nodes that can be grouped together in a single Edge Cluster. Edge nodes run BFD (Bidirectional Forward Detection) on both the management and tunnel networks in order to detect Edge Node failures. This fast detection of failure improves convergence. VMs support BFD with a minimum of one second on the BFD timer with three retries = three second failure detection. Bare metal edges support BFD with minimum of 300ms (BDF Tx/Rx timer) with three retries = 900ms failure detection. Only one Tier-0 gateway per Edge node; multiple Tier-1 gateways can be hosted per Edge node. Tier-0 gateway supports a maximum of eight equal cost paths which means there is a maximum of eight Edge nodes for ECMP. Single-Tier-Routing Two-Tier-Routing Edge Bridge \u2691 In the event you have VMs that are connected to a logical network in the NSX-T overlay, an admin can configure a \"bridge-backed logical switch\" that will provide Layer 2 connectivity with other VMs or physical devices that are \"outside\" the NSX-T overlay. Failure Domain \u2691 The Failure Domain is a logical grouping of Edge Nodes within an existing Edge Cluster. The benefit here is to help guarantee service availability of a Tier-1 SR (Service Router) ensuring the active and standby instances do not run in the same failure domain (i.e. same rack).","title":"NSX-T Edge Technology"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Edge%20Technology/#nsx-t-edge-technology","text":"Edge Nodes are simply \u2018service appliances\u2019 that provide pools of capacity and are reserved to running network services that are not distributed down to the hypervisors. They provide the physical network uplinks (pNICs) that connect to the physical network (underlay). NSX-T provides two types of Edge Nodes: bare metal edge and VM edge. Edge Clusters are a group of Edge Transport nodes that provide a scalable, high-throughput and highly available (redundant) gateway for logical networks created in NSX-T. More on clusters in a minute.","title":"NSX-T Edge Technology"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Edge%20Technology/#bare-metal-edge-vs-vm-edge","text":"","title":"Bare Metal Edge vs VM Edge"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Edge%20Technology/#deployment","text":"Bare metal edge nodes are deployed on a physical server and deployed via ISO or PXE boot. The NICs on the bare metal edge requires support for DPDK (reference the compatibility guide for more information). VM edge node is deployed using OVA/OVF or ISO file and only supported on an ESXi host (not KVM).","title":"Deployment"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Edge%20Technology/#performance","text":"Bare Metal Edge provides sub-second convergence, rapid fail over and higher throughput with low packet size. dedicated interface (NIC) for management (secondary interface can be used for management HA and can also be 1 Gbps). This management network cannot run on a Fast Path interface. Supports a maximum of 16 physical network uplinks for both overlay and external traffic; pNICs connected to ToR switching. Supports in-band management (Fast Path) meaning the management traffic can utilize an interface used by overlay or external network traffic (N-S traffic). Each pNIC (16) has an internal interface that is assigned to the DPDK (Data Plane Development Kit) Fast Path. There is flexibility when assigning the \"Fast Path interfaces\" to overlay or VLAN backed connectivity. Fast Path NICs \u2013 up to four dedicated to the data path using DPDK for high performance; external networks and the overlay use these NICs. The Edge VM contains four internal interfaces (vNICs). Management is reserved on \"eth0\" whereas DPDK Fast Path is assigned to interfaces \"fp-eth0, fp-eth1 and fp-eth2\" which are assigned to external connectivity for NSX-T overlay traffic (TEP traffic) and ToR switching. One vNIC for management. One vNIC for overlay traffic. Two vNICs for external traffic.","title":"Performance"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Edge%20Technology/#edge-clusters","text":"An Edge Cluster is simply a group of Edge transport nodes. Scale out capabilities for logical networks to the Edge nodes is accomplished via ECMP (Equal Cost Multi-Pathing). Tier-0 and Tier-1 gateways can be hosted on the same Edge Cluster or separate Edge Clusters. Scale out capabilities for logical networks to the Edge nodes is accomplished via ECMP (Equal Cost Multi-Pathing). Tier-0 and Tier-1 gateways can be hosted on the same Edge Cluster or separate Edge Clusters. Dependent upon the requirements for your network design, the Edge cluster could be \"dedicated\" to providing centralized such as NAT. Below is a list of some requirements / limitations on the Edge Clusters: There is a maximum of ten edge nodes that can be grouped together in a single Edge Cluster. Edge nodes run BFD (Bidirectional Forward Detection) on both the management and tunnel networks in order to detect Edge Node failures. This fast detection of failure improves convergence. VMs support BFD with a minimum of one second on the BFD timer with three retries = three second failure detection. Bare metal edges support BFD with minimum of 300ms (BDF Tx/Rx timer) with three retries = 900ms failure detection. Only one Tier-0 gateway per Edge node; multiple Tier-1 gateways can be hosted per Edge node. Tier-0 gateway supports a maximum of eight equal cost paths which means there is a maximum of eight Edge nodes for ECMP. Single-Tier-Routing Two-Tier-Routing","title":"Edge Clusters"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Edge%20Technology/#edge-bridge","text":"In the event you have VMs that are connected to a logical network in the NSX-T overlay, an admin can configure a \"bridge-backed logical switch\" that will provide Layer 2 connectivity with other VMs or physical devices that are \"outside\" the NSX-T overlay.","title":"Edge Bridge"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Edge%20Technology/#failure-domain","text":"The Failure Domain is a logical grouping of Edge Nodes within an existing Edge Cluster. The benefit here is to help guarantee service availability of a Tier-1 SR (Service Router) ensuring the active and standby instances do not run in the same failure domain (i.e. same rack).","title":"Failure Domain"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Management-Plane/","text":"NSX-T Management Plane \u2691 NSX-T Manager is at the core of the management plane and provides a wide system view of everything involved. It is a single API entry point responsible for maintaining things such as user configuration, user queries and operational responsibilities for the three planes (management, control, data). Saves the desired configuration and statistical information. The configuration is then pushed by NSX-T Manager to the control plane which then converts to an active configuration at the data plane level. All NSX-T components have a MPA (Management Plane Agent) which connects that components back to the NSX-T Manager.","title":"NSX-T Management Plane"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Management-Plane/#nsx-t-management-plane","text":"NSX-T Manager is at the core of the management plane and provides a wide system view of everything involved. It is a single API entry point responsible for maintaining things such as user configuration, user queries and operational responsibilities for the three planes (management, control, data). Saves the desired configuration and statistical information. The configuration is then pushed by NSX-T Manager to the control plane which then converts to an active configuration at the data plane level. All NSX-T components have a MPA (Management Plane Agent) which connects that components back to the NSX-T Manager.","title":"NSX-T Management Plane"},{"location":"Cloud/NSX-T/NSX-T-Architecture/NSX-T-Architecture/","text":"NSX-T Architecture \u2691 Single-Tier-Routing clear_artifacts","title":"NSX-T Architecture"},{"location":"Cloud/NSX-T/NSX-T-Architecture/NSX-T-Architecture/#nsx-t-architecture","text":"Single-Tier-Routing clear_artifacts","title":"NSX-T Architecture"},{"location":"Cloud/NSX-T/NSX-T-Architecture/NSX-T-Profiles/","text":"NSX-T Profiles \u2691 About NSX-T Profiles \u2691 Profiles in NSX-T are very useful and are used to ensure consistent configurations are propagated to the transport nodes. Just another way NSX-T reduces configuration complexity during post deployment steps as you prepare the environment for NSX-T. Uplink Profile \u2691 Defines how the uplinks for the transport nodes should be configured. Here you can configure how LAGs should be configure (if you plan on using them) along with the LACP mode, LACP Load Balancing method, number of uplinks (2 minimum) and LACP timeout options. \"Teamings\" will define how you want your uplinks to behave by defining the Teaming Policy, Active Uplinks and Standby Uplinks. NIOC Profile \u2691 Defines how to carve up bandwidth for the types of traffic. If you are familiar with how NIOC was configured on a vDS, this is really not that much different. You can specify different share values, impose limits (%) as well as reservations (%) which will guarantee specific bandwidth to traffic at all times. Edge Cluster Profiles \u2691 used to define how BFD (Bidirectional Forward Detection) will be applied on the Edge Cluster that services your environment. Here you can apply BFD Probe Internal (ms), PFD Allowed Hops, BFD Declare Dead Multiple and Standby Relocation Threshold (minutes). Edge Bridge Profile \u2691 Describes how an Edge Cluster can provide Layer 2 bridging capabilities between NSX-T and a logical switch that is backed by a traditional VLAN. Transport Node Profile \u2691 This profile has everything including which Transport Zone(s) you want the Node Profile to apply to, how the N-VDS should be deployed as well as associate other profiles to the transport node including NIOC Profile, Uplink Profile, LLDP Profile and so on. Here you can also configure Network Mappings for Installation and Uninstall which is useful when migrating your existing networks over to the N-VDS (including pNIC migration).","title":"NSX-T Profiles"},{"location":"Cloud/NSX-T/NSX-T-Architecture/NSX-T-Profiles/#nsx-t-profiles","text":"","title":"NSX-T Profiles"},{"location":"Cloud/NSX-T/NSX-T-Architecture/NSX-T-Profiles/#about-nsx-t-profiles","text":"Profiles in NSX-T are very useful and are used to ensure consistent configurations are propagated to the transport nodes. Just another way NSX-T reduces configuration complexity during post deployment steps as you prepare the environment for NSX-T.","title":"About NSX-T Profiles"},{"location":"Cloud/NSX-T/NSX-T-Architecture/NSX-T-Profiles/#uplink-profile","text":"Defines how the uplinks for the transport nodes should be configured. Here you can configure how LAGs should be configure (if you plan on using them) along with the LACP mode, LACP Load Balancing method, number of uplinks (2 minimum) and LACP timeout options. \"Teamings\" will define how you want your uplinks to behave by defining the Teaming Policy, Active Uplinks and Standby Uplinks.","title":"Uplink Profile"},{"location":"Cloud/NSX-T/NSX-T-Architecture/NSX-T-Profiles/#nioc-profile","text":"Defines how to carve up bandwidth for the types of traffic. If you are familiar with how NIOC was configured on a vDS, this is really not that much different. You can specify different share values, impose limits (%) as well as reservations (%) which will guarantee specific bandwidth to traffic at all times.","title":"NIOC Profile"},{"location":"Cloud/NSX-T/NSX-T-Architecture/NSX-T-Profiles/#edge-cluster-profiles","text":"used to define how BFD (Bidirectional Forward Detection) will be applied on the Edge Cluster that services your environment. Here you can apply BFD Probe Internal (ms), PFD Allowed Hops, BFD Declare Dead Multiple and Standby Relocation Threshold (minutes).","title":"Edge Cluster Profiles"},{"location":"Cloud/NSX-T/NSX-T-Architecture/NSX-T-Profiles/#edge-bridge-profile","text":"Describes how an Edge Cluster can provide Layer 2 bridging capabilities between NSX-T and a logical switch that is backed by a traditional VLAN.","title":"Edge Bridge Profile"},{"location":"Cloud/NSX-T/NSX-T-Architecture/NSX-T-Profiles/#transport-node-profile","text":"This profile has everything including which Transport Zone(s) you want the Node Profile to apply to, how the N-VDS should be deployed as well as associate other profiles to the transport node including NIOC Profile, Uplink Profile, LLDP Profile and so on. Here you can also configure Network Mappings for Installation and Uninstall which is useful when migrating your existing networks over to the N-VDS (including pNIC migration).","title":"Transport Node Profile"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Routing/","text":"Single-Tier-Routing Two-Tier-Routing","title":"Routing"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Single-Tier-Routing/","text":"What is Single-tier routing? \u2691 Single-tier routing is a NSX-T Tier-0 gateway that provides both distributed routing and centralized routing along with other services such as NAT, DHCP, load balancers and so on. The segments (subnets) in a single-tier topology are connected directly to the NSX-T gateway. VMs connected to these segments can communicate East-West as well as North-South to the external data center. There is a distributed routing (DR) component for this T0 gateway; this instance is created as a kernel module and will function as a \u2018local gateway\u2019 for the workloads connected to these segments. There is a logical interface (LIF) on the gateway that is used as the default gateway. Apply the gateway for the L2 segment, configure your VMs properly and traffic will begin to flow as expected. There are two distinct NSX-T components\u2026the DR (distributed router) and SR (services router). In vSphere, the ESXi host(s) have the DR component only whereas the Edge Node(s) have a merged DR/SR component. East-West routing is distributed by the hypervisor (aka host transport node); each hypervisor in the TZ is running a DR at the kernel level. When they are created they exist on the edge node as an SR and not distributed as a DR. Below is a list of some of the SR services that can be enabled in NSX-T: - Gateway Firewall - DHCP - VPN - NAT - Bridging - Service Interface - Physical network connectivity - Metadata Proxy","title":"What is Single-tier routing?"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Single-Tier-Routing/#what-is-single-tier-routing","text":"Single-tier routing is a NSX-T Tier-0 gateway that provides both distributed routing and centralized routing along with other services such as NAT, DHCP, load balancers and so on. The segments (subnets) in a single-tier topology are connected directly to the NSX-T gateway. VMs connected to these segments can communicate East-West as well as North-South to the external data center. There is a distributed routing (DR) component for this T0 gateway; this instance is created as a kernel module and will function as a \u2018local gateway\u2019 for the workloads connected to these segments. There is a logical interface (LIF) on the gateway that is used as the default gateway. Apply the gateway for the L2 segment, configure your VMs properly and traffic will begin to flow as expected. There are two distinct NSX-T components\u2026the DR (distributed router) and SR (services router). In vSphere, the ESXi host(s) have the DR component only whereas the Edge Node(s) have a merged DR/SR component. East-West routing is distributed by the hypervisor (aka host transport node); each hypervisor in the TZ is running a DR at the kernel level. When they are created they exist on the edge node as an SR and not distributed as a DR. Below is a list of some of the SR services that can be enabled in NSX-T: - Gateway Firewall - DHCP - VPN - NAT - Bridging - Service Interface - Physical network connectivity - Metadata Proxy","title":"What is Single-tier routing?"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Transport-Zones/","text":"NSX-T Transport Zones \u2691 About Transport Zones \u2691 Transport Zones (TZ) are used to define a group of ESXi hosts that can communicate with one another on a physical network. This communication takes place between the TEPs (Tunnel End-Points) which are vmkernel adapters on the transport node(s) in the TZ. A Transport Zone is a way to logically define one or more host clusters that will be used to provide NSX-T networking. They are virtual Layer 2 Domains (segments). There are two types of transport zones: Overlay or VLAN. You can pick one or the other but not both when planning the transport zone. Important information for Transport Zones \u2691 The NSX-T environment can contain one or more TZs. You must provide a name for the N-VDS that will be installed on the transport nodes (they will be added later to the TZ). A host can belong to multiple transport zones but a logical switch can only belong to one TZ. Therefore the span (or area) of a logical switch is limited to the transport zone. Overlay TZs are used by both the NSX Edges and the Host Transport Nodes. When the environment scales and a Host TN or NSX Edge node is added to an overlay TZ the N-VDS is installed on that host tn or NSX Edge. VLAN TZs are used by the NSX Edge for the VLAN uplinks. Anytime an NSX Edge is added to this type of transport a VLAN N-VDS is installed on the NSX Edge. The NVD-S is responsible for transmitting \"virtual-to-physical\" network packet flow by joining logical router uplinks with physical NIC downlinks essentially binding the virtual and physical worlds together. This is why planning the Uplink Profiles is important because it is describing how you want network traffic to communicate between the virtual and physical layers. Important restrictions for Transport Zones \u2691 A N-VDS can be attached to an Overlay TZ and VLAN TZ simultaneously whereby the N-VDS name will be the same. A N-VDS can only append to a single VLAN TZ but a transport node can append to multiple VLAN TZs with multiple N-VDS. A N-VDS can only append to a single Overlay TZ. Multiple N-VDS and traditional VDS can co-exist but a pNIC (physical port) can only be associated with one or the other. The pNIC cannot be associated with a N-VDS and VDS. A transport node can append to a single Overlay TZ. Consequently, only a single N-VDS can attach to an Overlay TZ on that transport node. What\u2019s the difference between VLAN backed and Overlay TZs? \u2691 A VLAN backed TZ (segment) is a \u2018layer 2 broadcast domain\u2019 and is applied as a VLAN on the traditional physical infrastructure. What this means is the network communication between two VMs residing on separate hosts and attached to the same VLAN network (i.e. VLAN 101 \u2013 192.168.101.x /24 network) will be transmitted over the VLAN between the two hosts. The one constraint (requirement) here is that VLAN must be provisioned (presented) to both hosts in order for those two VMs to communicate over that VLAN backed TZ (segment). In an Overlay TZ (segment), these same two VMs running on different hosts will have their Layer 2 transmission between the \u2018tunnel\u2019 that exists between the two transport nodes (hosts). This tunnel is an IP-based tunnel endpoint (TEP); this instance is maintained by NSX without the reliance for any segmented network configuration from the physical infrastructure. This type of TZ is where the physical network is truly \"decoupled\" by NSX.","title":"NSX-T Transport Zones"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Transport-Zones/#nsx-t-transport-zones","text":"","title":"NSX-T Transport Zones"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Transport-Zones/#about-transport-zones","text":"Transport Zones (TZ) are used to define a group of ESXi hosts that can communicate with one another on a physical network. This communication takes place between the TEPs (Tunnel End-Points) which are vmkernel adapters on the transport node(s) in the TZ. A Transport Zone is a way to logically define one or more host clusters that will be used to provide NSX-T networking. They are virtual Layer 2 Domains (segments). There are two types of transport zones: Overlay or VLAN. You can pick one or the other but not both when planning the transport zone.","title":"About Transport Zones"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Transport-Zones/#important-information-for-transport-zones","text":"The NSX-T environment can contain one or more TZs. You must provide a name for the N-VDS that will be installed on the transport nodes (they will be added later to the TZ). A host can belong to multiple transport zones but a logical switch can only belong to one TZ. Therefore the span (or area) of a logical switch is limited to the transport zone. Overlay TZs are used by both the NSX Edges and the Host Transport Nodes. When the environment scales and a Host TN or NSX Edge node is added to an overlay TZ the N-VDS is installed on that host tn or NSX Edge. VLAN TZs are used by the NSX Edge for the VLAN uplinks. Anytime an NSX Edge is added to this type of transport a VLAN N-VDS is installed on the NSX Edge. The NVD-S is responsible for transmitting \"virtual-to-physical\" network packet flow by joining logical router uplinks with physical NIC downlinks essentially binding the virtual and physical worlds together. This is why planning the Uplink Profiles is important because it is describing how you want network traffic to communicate between the virtual and physical layers.","title":"Important information for Transport Zones"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Transport-Zones/#important-restrictions-for-transport-zones","text":"A N-VDS can be attached to an Overlay TZ and VLAN TZ simultaneously whereby the N-VDS name will be the same. A N-VDS can only append to a single VLAN TZ but a transport node can append to multiple VLAN TZs with multiple N-VDS. A N-VDS can only append to a single Overlay TZ. Multiple N-VDS and traditional VDS can co-exist but a pNIC (physical port) can only be associated with one or the other. The pNIC cannot be associated with a N-VDS and VDS. A transport node can append to a single Overlay TZ. Consequently, only a single N-VDS can attach to an Overlay TZ on that transport node.","title":"Important restrictions for Transport Zones"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Transport-Zones/#whats-the-difference-between-vlan-backed-and-overlay-tzs","text":"A VLAN backed TZ (segment) is a \u2018layer 2 broadcast domain\u2019 and is applied as a VLAN on the traditional physical infrastructure. What this means is the network communication between two VMs residing on separate hosts and attached to the same VLAN network (i.e. VLAN 101 \u2013 192.168.101.x /24 network) will be transmitted over the VLAN between the two hosts. The one constraint (requirement) here is that VLAN must be provisioned (presented) to both hosts in order for those two VMs to communicate over that VLAN backed TZ (segment). In an Overlay TZ (segment), these same two VMs running on different hosts will have their Layer 2 transmission between the \u2018tunnel\u2019 that exists between the two transport nodes (hosts). This tunnel is an IP-based tunnel endpoint (TEP); this instance is maintained by NSX without the reliance for any segmented network configuration from the physical infrastructure. This type of TZ is where the physical network is truly \"decoupled\" by NSX.","title":"What\u2019s the difference between VLAN backed and Overlay TZs?"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Two-Tier-Routing/","text":"What is Two Tier Routing? \u2691 With two-tier routing, you will find both T0 and T1 gateways (virtual routers). The T0 gateway is common referred to as the \u2018provider\u2019 and the T1 would be the \u2018tenant\u2019. This design enables provider admins and tenant admins total control over their services and policies because they operate separately from one another. The T0 gateway handles all northbound traffic and can connect with one or more physical routers and/or L3 switches. Southbound T0 traffic traverses something called a \u2018RouterLink interface\u2019 which established between the T0 and T1 gateways. The T1 gateway has northbound connectivity to the T0 gateway through this interface and then southbound interface(s) are called \u2018downlinks\u2019 which are from the T1 gateway to one or more L2 segments. T1 routers cannot connect directly to the physical underlying infrastructure, only T0 routers can provide connectivity to the physical network commonly referred to as the underlay. The concepts of distributed routers (DR) and service routers (SR) are no different than with single-tier routing. One area that is different in this topology compared to single-tier is the use of the RouterLink Interface (Linked Port) which is used to connect T0 and T1 gateways. A peer connection is established using the 100.64.0.0/16 reserved address space (RFC 6598). It will appear in the configuration as a /31 subnet which you may see during the step-by-step exercise when establishing the connectivity between T0 and T1. This connectivity is entirely \u2018auto-plumbed\u2019 into the configuration and therefore no dynamic routing is required between T0 and T1. The fully distributed routing architecture of NSX-T is intended to provide routing functionality closest to the source; capable of extending it to multiple tiers. NSX-T supports both static routing as well as dynamic routing through the use of BGP on the T0 gateways. The T1 gateways support static routes but do not support any dynamic routing capabilities. This is were effective NSX-T Route Redistribution will come into play.","title":"What is Two Tier Routing?"},{"location":"Cloud/NSX-T/NSX-T-Architecture/Two-Tier-Routing/#what-is-two-tier-routing","text":"With two-tier routing, you will find both T0 and T1 gateways (virtual routers). The T0 gateway is common referred to as the \u2018provider\u2019 and the T1 would be the \u2018tenant\u2019. This design enables provider admins and tenant admins total control over their services and policies because they operate separately from one another. The T0 gateway handles all northbound traffic and can connect with one or more physical routers and/or L3 switches. Southbound T0 traffic traverses something called a \u2018RouterLink interface\u2019 which established between the T0 and T1 gateways. The T1 gateway has northbound connectivity to the T0 gateway through this interface and then southbound interface(s) are called \u2018downlinks\u2019 which are from the T1 gateway to one or more L2 segments. T1 routers cannot connect directly to the physical underlying infrastructure, only T0 routers can provide connectivity to the physical network commonly referred to as the underlay. The concepts of distributed routers (DR) and service routers (SR) are no different than with single-tier routing. One area that is different in this topology compared to single-tier is the use of the RouterLink Interface (Linked Port) which is used to connect T0 and T1 gateways. A peer connection is established using the 100.64.0.0/16 reserved address space (RFC 6598). It will appear in the configuration as a /31 subnet which you may see during the step-by-step exercise when establishing the connectivity between T0 and T1. This connectivity is entirely \u2018auto-plumbed\u2019 into the configuration and therefore no dynamic routing is required between T0 and T1. The fully distributed routing architecture of NSX-T is intended to provide routing functionality closest to the source; capable of extending it to multiple tiers. NSX-T supports both static routing as well as dynamic routing through the use of BGP on the T0 gateways. The T1 gateways support static routes but do not support any dynamic routing capabilities. This is were effective NSX-T Route Redistribution will come into play.","title":"What is Two Tier Routing?"},{"location":"DevOps/Continuous-Integration/GitLab-CICD/clear_artifacts/","text":"Script to clear GitLab CI/CD Artifacts \u2691 import requests import json class BearerAuth ( requests . auth . AuthBase ): def __init__ ( self , token ): self . token = token def __call__ ( self , r ): r . headers [ \"authorization\" ] = \"Bearer \" + self . token return r project = '804' token = 'ijuiosjdiof' for page in range ( 1 , 200 ): url = f 'https://gitlab.com/api/v4/projects/ { project } /jobs?per_page=100&page= { page } ' print ( f 'Getting jobs from { url } ' ) response = requests . get ( url , auth = BearerAuth ( token )) data = json . loads ( response . text ) for item in data : url = f 'https://gitlab.com/api/v4/projects/ { project } /jobs/ { item [ \"id\" ] } /artifacts' print ( f 'Running on { url } ' ) response = requests . delete ( url , auth = BearerAuth ( token ))","title":"Script to clear GitLab CI/CD Artifacts"},{"location":"DevOps/Continuous-Integration/GitLab-CICD/clear_artifacts/#script-to-clear-gitlab-cicd-artifacts","text":"import requests import json class BearerAuth ( requests . auth . AuthBase ): def __init__ ( self , token ): self . token = token def __call__ ( self , r ): r . headers [ \"authorization\" ] = \"Bearer \" + self . token return r project = '804' token = 'ijuiosjdiof' for page in range ( 1 , 200 ): url = f 'https://gitlab.com/api/v4/projects/ { project } /jobs?per_page=100&page= { page } ' print ( f 'Getting jobs from { url } ' ) response = requests . get ( url , auth = BearerAuth ( token )) data = json . loads ( response . text ) for item in data : url = f 'https://gitlab.com/api/v4/projects/ { project } /jobs/ { item [ \"id\" ] } /artifacts' print ( f 'Running on { url } ' ) response = requests . delete ( url , auth = BearerAuth ( token ))","title":"Script to clear GitLab CI/CD Artifacts"},{"location":"DevOps/Infrastructure-Solutions/Container/Docker/docker%20commands/","text":"","title":"Docker commands"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/K3S/install/","text":"curl -sfL https://get.k3s.io | K3S_URL=https://manager01.fritz.box:6443 K3S_TOKEN=\"\" sh -","title":"Install"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/K3S/raspberry/","text":"","title":"Raspberry"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/Networking/kube-vip/","text":"Kube-VIP \u2691 The hybrid mode works for the control plane and kubernetes service https://kube-vip.io/hybrid/","title":"Kube-VIP"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/Networking/kube-vip/#kube-vip","text":"The hybrid mode works for the control plane and kubernetes service https://kube-vip.io/hybrid/","title":"Kube-VIP"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/Networking/metallb/","text":"MetalLB \u2691 Install \u2691 https://metallb.universe.tf/installation/ kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.10.2/manifests/namespace.yaml kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.10.2/manifests/metallb.yaml config \u2691 apiVersion: v1 kind: ConfigMap metadata: namespace: metallb-system name: config data: config: | address-pools: - name: default protocol: layer2 addresses: - 192.168.3.200-192.168.3.250","title":"MetalLB"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/Networking/metallb/#metallb","text":"","title":"MetalLB"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/Networking/metallb/#install","text":"https://metallb.universe.tf/installation/ kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.10.2/manifests/namespace.yaml kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.10.2/manifests/metallb.yaml","title":"Install"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/Networking/metallb/#config","text":"apiVersion: v1 kind: ConfigMap metadata: namespace: metallb-system name: config data: config: | address-pools: - name: default protocol: layer2 addresses: - 192.168.3.200-192.168.3.250","title":"config"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/CronJob/","text":"Test CronJob \u2691 kubectl create job --from=cronjob/cc-net-esa-wlc-flexconnect-check test-job-1","title":"Test CronJob"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/CronJob/#test-cronjob","text":"kubectl create job --from=cronjob/cc-net-esa-wlc-flexconnect-check test-job-1","title":"Test CronJob"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/busybox/","text":"kubectl run -i --tty --rm debug --image=busybox --restart=Never -- sh","title":"Busybox"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/delete/","text":"delete pods \u2691 kubectl get pods -n default | grep Error | cut -d' ' -f 1 | xargs kubectl delete pod","title":"delete pods"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/delete/#delete-pods","text":"kubectl get pods -n default | grep Error | cut -d' ' -f 1 | xargs kubectl delete pod","title":"delete pods"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/label/","text":"nodes \u2691 add node label \u2691 kubectl label node node01 node-role.kubernetes.io/name delete node label \u2691 kubectl label node node01 node-role.kubernetes.io/name-","title":"nodes"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/label/#nodes","text":"","title":"nodes"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/label/#add-node-label","text":"kubectl label node node01 node-role.kubernetes.io/name","title":"add node label"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/label/#delete-node-label","text":"kubectl label node node01 node-role.kubernetes.io/name-","title":"delete node label"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/serviceaccount/","text":"ServiceAccounts \u2691 deploy \u2691 gitlab-service-account.yml --- apiVersion: v1 kind: ServiceAccount metadata: name: gitlab-service-account --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: gitlab-service-account-role-binding roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: gitlab-service-account namespace: default test local \u2691 kubectl get secrets | grep gitlab-service-account kubectl describe secret gitlab-service-account-token-.... export K8S_SERVER = \"https://10.24.70.26:6443\" export K8S_CLUSTER = \"gitlab-test\" export K8S_USER = \"gitlab-service-account\" export K8S_USER_TOKEN = \"\" kubectl config set-cluster $K8S_CLUSTER --server = $K8S_SERVER --insecure-skip-tls-verify = true kubectl config set-credentials $K8S_USER --token = $K8S_USER_TOKEN kubectl config set-context $K8S_CLUSTER --cluster = $K8S_CLUSTER --user = $K8S_USER kubectl config use-context $K8S_CLUSTER","title":"ServiceAccounts"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/serviceaccount/#serviceaccounts","text":"","title":"ServiceAccounts"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/serviceaccount/#deploy","text":"gitlab-service-account.yml --- apiVersion: v1 kind: ServiceAccount metadata: name: gitlab-service-account --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: gitlab-service-account-role-binding roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: gitlab-service-account namespace: default","title":"deploy"},{"location":"DevOps/Infrastructure-Solutions/Container/Kubernetes/kubectl/serviceaccount/#test-local","text":"kubectl get secrets | grep gitlab-service-account kubectl describe secret gitlab-service-account-token-.... export K8S_SERVER = \"https://10.24.70.26:6443\" export K8S_CLUSTER = \"gitlab-test\" export K8S_USER = \"gitlab-service-account\" export K8S_USER_TOKEN = \"\" kubectl config set-cluster $K8S_CLUSTER --server = $K8S_SERVER --insecure-skip-tls-verify = true kubectl config set-credentials $K8S_USER --token = $K8S_USER_TOKEN kubectl config set-context $K8S_CLUSTER --cluster = $K8S_CLUSTER --user = $K8S_USER kubectl config use-context $K8S_CLUSTER","title":"test local"},{"location":"DevOps/Infrastructure-Solutions/Container/additional/Traefik/Excluding/","text":"services: whoami: image: \"traefik/whoami\" container_name: \"whoami-test\" labels: - \"traefik.enable=true\" - \"traefik.http.routers.whoami-test.rule=Host(`whoami-test.fritz.box`)\" - \"traefik.http.routers.whoami-test.entrypoints=http\" - \"traefik.http.routers.whoami-test.middlewares=intern_whitelist\" - \"traefik.http.middlewares.intern_whitelist.ipwhitelist.sourcerange=192.168.2.0/23\" - \"traefik.http.middlewares.intern_whitelist.ipwhitelist.ipstrategy.excludedips=192.168.2.1, 192.168.2.124\"","title":"Excluding"},{"location":"DevOps/Infrastructure-Solutions/Container/additional/Traefik/External%20Services/","text":"http: routers: intern: {} entryPoints: - \"http\" - \"https\" rule: \"Host(`HostRegexp(`fritz.box`, `{subdomain:[a-z]+}.fritz.box`, ...)`)\" pihole: entryPoints: - \"http\" - \"https\" rule: \"Host(`pihole.fritz.box`)\" service: pihole middlewares: - addprefix-pihole services: pihole: loadBalancer: servers: - url: \"http://192.168.2.19:80\" passHostHeader: true middlewares: addprefix-pihole: addPrefix: prefix: \"/admin\"","title":"External Services"},{"location":"DevOps/Infrastructure-as-Code/Helm/","text":"","title":"Helm"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/","text":"20 rules of formulating knowledge \u2691 1. Do not learn if you don't understand \u2691 2. Learn before you memorize \u2691 You need to build an overall picture of the learned knowledge in order to memorize it. Do not start from memorizing loosely related facts! 3. Build upon the basics \u2691 4. Stick to the minimum information principle \u2691 The material you learn must be formulated in as simple way at is is. 5. Cloze deletion is easy and effective \u2691 Cloze deletion is a sentence with its parts missing and replaced by three dots. 6. Use Imagery \u2691 7. Use mnemonic techniques \u2691 8. Graphic deletions is as good as cloze deletion \u2691 9. Avoid sets \u2691 10. Avoid enumeration \u2691 11. Combat interference \u2691 When you learn about similar things you often confuse them. You need to make items as unambiguous as possible. 12. Optimized wording \u2691 13. Refer to other memories \u2691 14. Personalize and provide examples \u2691 15. Rely on emotional states \u2691 16. Context cues simplify wording \u2691 17. Redundancy does not contradict minimum information principle \u2691 18. Provide sources \u2691 19. Provide data stamping \u2691 20 Prioritize \u2691 Summary \u2691 Do not learn if you do not understand Learn before you memorize - build the picture of the whole before you dismember it into simple items in SuperMemo. If the whole shows holes, review it again! Build upon the basics - never jump both feet into a complex manual because you may never see the end. Well remembered basics will help the remaining knowledge easily fit in Stick to the minimum information principle - if you continue forgetting an item, try to make it as simple as possible. If it does not help, see the remaining rules (cloze deletion, graphics, mnemonic techniques, converting sets into enumerations, etc.) Cloze deletion is easy and effective - completing a deleted word or phrase is not only an effective way of learning. Most of all, it greatly speeds up formulating knowledge and is highly recommended for beginners Use imagery - a picture is worth a thousand words Use mnemonic techniques - read about peg lists and mind maps. Study the books by Tony Buzan. Learn how to convert memories into funny pictures. You won't have problems with phone numbers and complex figures Graphic deletion is as good as cloze deletion - obstructing parts of a picture is great for learning anatomy, geography and more Avoid sets - larger sets are virtually un-memorizable unless you convert them into enumerations! Avoid enumerations - enumerations are also hard to remember but can be dealt with using cloze deletion Combat interference - even the simplest items can be completely intractable if they are similar to other items. Use examples, context cues, vivid illustrations, refer to emotions, and to your personal life Optimize wording - like you reduce mathematical equations, you can reduce complex sentences into smart, compact and enjoyable maxims Refer to other memories - building memories on other memories generates a coherent and hermetic structure that forgetting is less likely to affect. Build upon the basics and use planned redundancy to fill in the gaps Personalize and provide examples - personalization might be the most effective way of building upon other memories. Your personal life is a gold mine of facts and events to refer to. As long as you build a collection for yourself, use personalization richly to build upon well established memories Rely on emotional states - emotions are related to memories. If you learn a fact in the sate of sadness, you are more likely to recall it if when you are sad. Some memories can induce emotions and help you employ this property of the brain in remembering Context cues simplify wording - providing context is a way of simplifying memories, building upon earlier knowledge and avoiding interference Redundancy does not contradict minimum information principle - some forms of redundancy are welcome. There is little harm in memorizing the same fact as viewed from different angles. Passive and active approach is particularly practicable in learning word-pairs. Memorizing derivation steps in problem solving is a way towards boosting your intellectual powers! Provide sources - sources help you manage the learning process, updating your knowledge, judging its reliability, or importance Provide date stamping - time stamping is useful for volatile knowledge that changes in time Prioritize - effective learning is all about prioritizing. In incremental reading you can start from badly formulated knowledge and improve its shape as you proceed with learning (in proportion to the cost of inappropriate formulation). If need be, you can review pieces of knowledge again, split it into parts, reformulate, reprioritize, or delete. See also: Incremental reading , Devouring knowledge , Flow of knowledge , Using tasklists","title":"20 rules of formulating knowledge"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#20-rules-of-formulating-knowledge","text":"","title":"20 rules of formulating knowledge"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#1-do-not-learn-if-you-dont-understand","text":"","title":"1. Do not learn if you don't understand"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#2-learn-before-you-memorize","text":"You need to build an overall picture of the learned knowledge in order to memorize it. Do not start from memorizing loosely related facts!","title":"2. Learn before you memorize"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#3-build-upon-the-basics","text":"","title":"3. Build upon the basics"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#4-stick-to-the-minimum-information-principle","text":"The material you learn must be formulated in as simple way at is is.","title":"4. Stick to the minimum information principle"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#5-cloze-deletion-is-easy-and-effective","text":"Cloze deletion is a sentence with its parts missing and replaced by three dots.","title":"5. Cloze deletion is easy and effective"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#6-use-imagery","text":"","title":"6. Use Imagery"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#7-use-mnemonic-techniques","text":"","title":"7. Use mnemonic techniques"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#8-graphic-deletions-is-as-good-as-cloze-deletion","text":"","title":"8. Graphic deletions is as good as cloze deletion"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#9-avoid-sets","text":"","title":"9. Avoid sets"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#10-avoid-enumeration","text":"","title":"10. Avoid enumeration"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#11-combat-interference","text":"When you learn about similar things you often confuse them. You need to make items as unambiguous as possible.","title":"11. Combat interference"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#12-optimized-wording","text":"","title":"12. Optimized wording"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#13-refer-to-other-memories","text":"","title":"13. Refer to other memories"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#14-personalize-and-provide-examples","text":"","title":"14. Personalize and provide examples"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#15-rely-on-emotional-states","text":"","title":"15. Rely on emotional states"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#16-context-cues-simplify-wording","text":"","title":"16. Context cues simplify wording"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#17-redundancy-does-not-contradict-minimum-information-principle","text":"","title":"17. Redundancy does not contradict minimum information principle"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#18-provide-sources","text":"","title":"18. Provide sources"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#19-provide-data-stamping","text":"","title":"19. Provide data stamping"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#20-prioritize","text":"","title":"20 Prioritize"},{"location":"Misc/20%20rules%20of%20formulating%20knowledge/#summary","text":"Do not learn if you do not understand Learn before you memorize - build the picture of the whole before you dismember it into simple items in SuperMemo. If the whole shows holes, review it again! Build upon the basics - never jump both feet into a complex manual because you may never see the end. Well remembered basics will help the remaining knowledge easily fit in Stick to the minimum information principle - if you continue forgetting an item, try to make it as simple as possible. If it does not help, see the remaining rules (cloze deletion, graphics, mnemonic techniques, converting sets into enumerations, etc.) Cloze deletion is easy and effective - completing a deleted word or phrase is not only an effective way of learning. Most of all, it greatly speeds up formulating knowledge and is highly recommended for beginners Use imagery - a picture is worth a thousand words Use mnemonic techniques - read about peg lists and mind maps. Study the books by Tony Buzan. Learn how to convert memories into funny pictures. You won't have problems with phone numbers and complex figures Graphic deletion is as good as cloze deletion - obstructing parts of a picture is great for learning anatomy, geography and more Avoid sets - larger sets are virtually un-memorizable unless you convert them into enumerations! Avoid enumerations - enumerations are also hard to remember but can be dealt with using cloze deletion Combat interference - even the simplest items can be completely intractable if they are similar to other items. Use examples, context cues, vivid illustrations, refer to emotions, and to your personal life Optimize wording - like you reduce mathematical equations, you can reduce complex sentences into smart, compact and enjoyable maxims Refer to other memories - building memories on other memories generates a coherent and hermetic structure that forgetting is less likely to affect. Build upon the basics and use planned redundancy to fill in the gaps Personalize and provide examples - personalization might be the most effective way of building upon other memories. Your personal life is a gold mine of facts and events to refer to. As long as you build a collection for yourself, use personalization richly to build upon well established memories Rely on emotional states - emotions are related to memories. If you learn a fact in the sate of sadness, you are more likely to recall it if when you are sad. Some memories can induce emotions and help you employ this property of the brain in remembering Context cues simplify wording - providing context is a way of simplifying memories, building upon earlier knowledge and avoiding interference Redundancy does not contradict minimum information principle - some forms of redundancy are welcome. There is little harm in memorizing the same fact as viewed from different angles. Passive and active approach is particularly practicable in learning word-pairs. Memorizing derivation steps in problem solving is a way towards boosting your intellectual powers! Provide sources - sources help you manage the learning process, updating your knowledge, judging its reliability, or importance Provide date stamping - time stamping is useful for volatile knowledge that changes in time Prioritize - effective learning is all about prioritizing. In incremental reading you can start from badly formulated knowledge and improve its shape as you proceed with learning (in proportion to the cost of inappropriate formulation). If need be, you can review pieces of knowledge again, split it into parts, reformulate, reprioritize, or delete. See also: Incremental reading , Devouring knowledge , Flow of knowledge , Using tasklists","title":"Summary"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/","text":"Cumulus Fabric with VXLAN EVPN & BGP \u2691 About \u2691 A clos topology switching fabric will be build in this page. Heavily inspired by the Book [[Cloud Native Data Center Networking]] Interfaces \u2691 Switch Ports \u2691 auto swp5s0 iface swp5s0 alias Cohesity link-speed 25000 link-duplex full bridge-vids 103 107 108 Bridge \u2691 iface bridge bridge-vlan-aware yes bridge-ports swp3s0 swp3s1 vni10100 vni10101 bridge-vids 100 101 102 103 bridge-pvid 1 bridge-vlan-aware yes The VLAN-aware mode in Cumulus Linux implements a configuration model with one single instance of Spanning Tree. Each physical bridge member port is configured with the list of allowed VLANs as well as its port VLAN ID. This significantly reduces the configuration size, and eliminates the large overhead of managing the port/VLAN instances as subinterfaces. ifreload -a to reload interface configuration bridge-pvid 1 sets the native VLAN. The Primary VLAN Identifier (PVID) of the bridge defaults to 1. You do not have to specify bridge-pvid for a bridge or a port. However, even though this does not affect the configuration, it helps other users for readability By default, the bridge port inherits the bridge VIDs, however, you can configure a port to override the bridge VIDs. SVIs \u2691 auto vlan103 iface vlan103 alias COHESITY vlan-id 103 address 10.136.16.14/24 address 2a00:e400:2:250::14/64 address-virtual 02:0a:88:10:00:67 10.136.16.1/24 address-virtual 06:00:02:02:00:67 2a00:e400:2:250::1/64 vlan-raw-device bridge vrf xal-001 address is the unique IP address of the leaf on the specified VNI. address-virtual is shared across all the leaves that carry this VNI. Servers are configured to use this IP address as the default gateway address to allow a server to be attached to any rack and not have to change its default gateway configuration. vxlan-raw-device bridge Linux allows the presence of multiple 802.1Q bridges on the same device. An in interface is assigned to only of of the bridges and so there is no ambiguity on the link about the use of a VLAN. VXLAN Interfaces \u2691 auto vni10100 iface vni10100 bridge-access 100 bridge-arp-nd-suppress on bridge-learning off mstpctl-bpduguard yes mstpctl-portbpdufilter yes mtu 9166 vxlan-id 10100 vxlan-local-tunnelip 10.136.128.3 iface vni10100 Each VXLAN VNI is represented by a device in the Linux kernel bridge-access maps the VNI to a local VLAN ID bridge-learning off We don't want to enable learning of remote MAC address because we have EVPN. So we disable learning on the VNIs. mstpctl-bpduguard yes You can configure BPDU guard to protect the spanning tree topology from unauthorized switches affecting the forwarding path. For example, if you add a new switch to an access port off a leaf switch and this new switch is configured with a low priority, it might become the new root switch and affect the forwarding path for the entire layer 2 topology. mstpctl-portbpdufilter yes You can enable bpdufilter on a switch port, which filters BPDUs in both directions. This disables STP on the port as no BPDUs are transiting. vxlan-local-tunnelip 10.136.128.3 This specifies the local source IP address to be used when CLAG isn't operational. When CLAG is operational, the address specified in point 2 is used as the tunnel source IP address. VRFs \u2691 auto xal-001 iface xal-001 vrf-table auto auto xal-002 iface xal-002 vrf-table auto vrf-table auto table id is automatically assigned Routing \u2691 BGP \u2691 Overlay and underlay \u2691 The BGP process on the spines needs to retain information it receives about both the overlay and the underlay. It uses the underlay information to build the underlay packet forwarding table. It needs to retain the overlay information it receives from a leaf to pass it to the other leaves (functioning like a RR). However, the spines don\u2019t know anything about virtual networks and will drop the information about them unless otherwise instructed. FRR automatically makes the spines keep that information when it recognizes that the same session is used for carrying both underlay and overlay routes. In other vendor implementations that support a single eBGP session model, additional configuration might need to be added. Unnumbered BGP \u2691 IPv6 link-local address \u2691 When enabled on a link, IPv6 automatically generates an IPv6 address that is valid only on that link, a link-local address (LLA). Most often, the interface MAC address is used to generate the address. IPv6 LLAs have a well-defined format: they start with fe80. An example of an IPv6 LLA is fe80::5054:ff:fe6d:4cbe. Unnumbered BGP uses this LLA to set up the TCP connection. Instead of asking the user to specify this, FRR uses the interface name to understand that the user wants to use the IPv6 LLA to establish the BGP peering. So, if fe80::5054:ff:fe6d:4cbe is the IPv6 LLA of the interface, FRR expects to receive a connect request on that address from the peer on that interface. Alternatively, it uses that address to send the connect request to the peer. However, to establish a connection with a remote entity, BGP needs the IPv6 LLA of the interface on the other end of the link. How does a node get that automatically? Via IPv6 router advertisement. IPv6 router advertisement \u2691 To allow hosts and routers to automatically discover neighboring routers, IPv6 designers added router advertisement (RA). RA is one of the messages used in IPv6\u2019s NDP. IPv6 NDP is the IPv6 equivalent of IPv4\u2019s ARP. When enabled on an interface, RA periodically announces the interface\u2019s IPv6 addresses, including the LLA. Thus, one end can automatically determine the other end\u2019s IPv6 address. Like IPv6, RA is universally implemented these days on both hosts and routers. The IPv6 LLA is used only to establish a TCP connection for starting a BGP session. Besides enabling IPv6 on a link, which is typically enabled automatically, and the enabling of the IPv6 router advertisement on the link, no other knowledge of IPv6 is expected of the operator. RFC 5549 \u2691 Establishing a TCP connection over IPv6 LLA isn\u2019t enough. To exchange IPv4 routes, we need a next-hop IPv4 address. But the interface on which BGP peering has been established has no IPv4 address and there is no other reachable IPv4 address for the router to advertise. So how does this work? There are two parts to this: a control-plane part and a packet forwarding (or data plane) part. The control-plane part involves implementing a standard, well-defined extension to encoding BGP\u2019s next-hop value. That standard is defined in RFC 5549, which is titled \u201cAdvertising IPv4 Network Layer Reachability Information with an IPv6 Next Hop.\u201d Remember, an IPv4 NLRI is just the route. So, this RFC defines how to advertise an IPv4 route with a next-hop IPv6 address. As with any other BGP extension, the support for encoding and processing an IPv4 route with an IPv6 next hop is first negotiated as part of the capability exchange in the BGP OPEN message. Only if both sides of a peering session support this capability is this method of advertising IPv4 routes with IPv6 next hop used. The BGP capability to indicate support for RFC 5549 is called extended next hop. The IPv6 RA gives us not only the link-local IPv6 address of the peer router, but also the MAC address of the peer interface on that router. So, for any given IPv6 link local address, we have its corresponding MAC address. Packet-switching silicon typically has a route pointing to a group of next hops, and each entry in the next hop only contains the MAC address (and VLAN). So the packet-switching silicon\u2019s routing table can be populated with an IPv4 route with the next-hop MAC address with this information. Thus, the information from the RFC 5549 encoding can be used to populate the packet-switching silicon just as if we had received an IPv4 route with an IPv4 next-hop address. RFC 5549 with FRR \u2691 The next-hop router\u2019s IP address is needed for only one trivial thing: it appears in the output of commands displaying the route. You can work around this by using a dummy IPv4 address. FRR uses 169.254.0.1 as this dummy IPv4 address. How FRR implements Unnumbered BGP \u2691 FRR implements IPv6 RA natively. FRR\u2019s RA when enabled on an interface announces its own LLA and MAC address. RA packets are used with a link-local multicast address and so they\u2019re never forwarded. On receiving an RA packet from a peer router on an interface, FRR\u2019s RA extracts the MAC address and the associated IPv6 LLA. Now that the interface\u2019s peering address is known, FRR kicks BGP into action to start connection establishment using the learned IPv6 LLA. After a successful BGP connection establishment, BGP uses capability negotiation to ensure that both sides of the peering session support RFC 5549. BGP receives a route advertisement for a route, say 10.0.0.11/32, from the peer with the peer\u2019s IPv6 LLA (and global IPv6 address if one is configured). If BGP selects this path as the best path to reach 10.0.0.11/32, it passes this route down to the RIB process (called zebra in FRR), with the next hop set to the IPv6 LLA received in the BGP UPDATE message. Let\u2019s assume the RIB picks this BGP route as the best route with which to populate the FIB. The RIB process now consults its database to see whether it has the information for the MAC address associated with this IPv6 LLA. It sees that there is such an entry. The RIB process now adds a static ARP entry for 169.254.0.1 with this MAC address, with the peering interface as the outgoing interface. The RIB process then pushes the route into the kernel routing table with a next hop of 169.254.0.1 and an outgoing interface set to that of the peering interface. interface {{ swp.name }} ipv6 nd ra-interval 5 no ipv6 nd suppress-ra ! router bgp 65011 bgp router-id 10.0.0.11 neighbor ISL capability extended-nexthop When you specify neighbor swp1 interface..., FRR assumes that you\u2019re using unnumbered BGP, enables RA automatically on that interface, and advertises the capability in the BGP peering session over that interface. FRR Configuration \u2691 router bgp 4213010101 bgp router-id 10.136.128.3 bgp bestpath as-path multipath-relax bgp bestpath compare-routerid neighbor FABRIC peer-group neighbor FABRIC remote-as external neighbor FABRIC bfd 5 200 200 neighbor swp15 interface peer-group FABRIC neighbor swp16 interface peer-group FABRIC ! address-family ipv4 unicast redistribute connected route-map rm_LOOPBACK_ONLY neighbor FABRIC activate exit-address-family ! address-family ipv6 unicast redistribute connected route-map rm_LOOPBACK_ONLY neighbor FABRIC activate exit-address-family ! address-family l2vpn evpn neighbor FABRIC activate advertise-all-vni advertise ipv4 unicast advertise ipv6 unicast exit-address-family ! address-family l2vpn evpn activates EVPN Peer Group \u2691 To simplify repetition when configuring multiple neighbors, most routing suites support a form of templating called peer group. The user creates a peer group with a name and then proceeds to configure the desired attributes for neighbor connection (such as remote-as, connection timers, and the use of BFD). In the next step, the operator assigns each real neighbor to the created peer group, thus avoiding the need to type the same boring stuff over and over again. Routing policy \u2691 Routing policy, at its simplest, specifies when to accept or reject route advertisements. Based on where they\u2019re used, the accept or reject could apply to routes received from a peer, routes advertised to a peer, and redistributed routes. A routing policy consists of a sequence of if-then-else statements, with matches and actions to be taken on a successful match. Route Maps \u2691 Route maps are a common way to implement routing policies. {# default route maps and prefix lists#} {{''}} ip prefix-list pl_DEFAULT_ONLY_4 seq 10 permit 0.0.0.0/0 ip prefix-list pl_DEFAULT_ONLY_4 seq 20 deny any ! ipv6 prefix-list pl_DEFAULT_ONLY_6 seq 10 permit ::/0 ipv6 prefix-list pl_DEFAULT_ONLY_6 seq 20 deny any ! route-map rm_DEFAULT_ONLY_4 permit 10 match ip address prefix-list pl_DEFAULT_ONLY_4 ! route-map rm_DEFAULT_ONLY_4 deny 20 ! route-map rm_DEFAULT_ONLY_6 permit 10 match ipv6 address prefix-list pl_DEFAULT_ONLY_6 ! route-map rm_DEFAULT_ONLY_6 deny 20 ! route-map rm_LOOPBACK_ONLY permit 10 match interface lo ! route-map rm_LOOPBACK_ONLY deny 20 ! Firewalling \u2691 The border leaves have interfaces to a firewall. One connection belongs to the green VRF and the other to the black VRF. The firewalls have two BGP sessions: one over the green subinterface and one over the black interface. The firewall just readvertise the routes learned via the green link to the BGP session over the black link, and vice versa. Thus, the default route learned by the border router via the internet router is sent to the firewall via the black link. The firewall readvertises this over the green link BGP session. From the perspective of traffic traversing form the internal to the external network, traffic now automatically flows through the firewall.","title":"Cumulus Fabric with VXLAN EVPN & BGP"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#cumulus-fabric-with-vxlan-evpn-bgp","text":"","title":"Cumulus Fabric with VXLAN EVPN &amp; BGP"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#about","text":"A clos topology switching fabric will be build in this page. Heavily inspired by the Book [[Cloud Native Data Center Networking]]","title":"About"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#interfaces","text":"","title":"Interfaces"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#switch-ports","text":"auto swp5s0 iface swp5s0 alias Cohesity link-speed 25000 link-duplex full bridge-vids 103 107 108","title":"Switch Ports"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#bridge","text":"iface bridge bridge-vlan-aware yes bridge-ports swp3s0 swp3s1 vni10100 vni10101 bridge-vids 100 101 102 103 bridge-pvid 1 bridge-vlan-aware yes The VLAN-aware mode in Cumulus Linux implements a configuration model with one single instance of Spanning Tree. Each physical bridge member port is configured with the list of allowed VLANs as well as its port VLAN ID. This significantly reduces the configuration size, and eliminates the large overhead of managing the port/VLAN instances as subinterfaces. ifreload -a to reload interface configuration bridge-pvid 1 sets the native VLAN. The Primary VLAN Identifier (PVID) of the bridge defaults to 1. You do not have to specify bridge-pvid for a bridge or a port. However, even though this does not affect the configuration, it helps other users for readability By default, the bridge port inherits the bridge VIDs, however, you can configure a port to override the bridge VIDs.","title":"Bridge"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#svis","text":"auto vlan103 iface vlan103 alias COHESITY vlan-id 103 address 10.136.16.14/24 address 2a00:e400:2:250::14/64 address-virtual 02:0a:88:10:00:67 10.136.16.1/24 address-virtual 06:00:02:02:00:67 2a00:e400:2:250::1/64 vlan-raw-device bridge vrf xal-001 address is the unique IP address of the leaf on the specified VNI. address-virtual is shared across all the leaves that carry this VNI. Servers are configured to use this IP address as the default gateway address to allow a server to be attached to any rack and not have to change its default gateway configuration. vxlan-raw-device bridge Linux allows the presence of multiple 802.1Q bridges on the same device. An in interface is assigned to only of of the bridges and so there is no ambiguity on the link about the use of a VLAN.","title":"SVIs"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#vxlan-interfaces","text":"auto vni10100 iface vni10100 bridge-access 100 bridge-arp-nd-suppress on bridge-learning off mstpctl-bpduguard yes mstpctl-portbpdufilter yes mtu 9166 vxlan-id 10100 vxlan-local-tunnelip 10.136.128.3 iface vni10100 Each VXLAN VNI is represented by a device in the Linux kernel bridge-access maps the VNI to a local VLAN ID bridge-learning off We don't want to enable learning of remote MAC address because we have EVPN. So we disable learning on the VNIs. mstpctl-bpduguard yes You can configure BPDU guard to protect the spanning tree topology from unauthorized switches affecting the forwarding path. For example, if you add a new switch to an access port off a leaf switch and this new switch is configured with a low priority, it might become the new root switch and affect the forwarding path for the entire layer 2 topology. mstpctl-portbpdufilter yes You can enable bpdufilter on a switch port, which filters BPDUs in both directions. This disables STP on the port as no BPDUs are transiting. vxlan-local-tunnelip 10.136.128.3 This specifies the local source IP address to be used when CLAG isn't operational. When CLAG is operational, the address specified in point 2 is used as the tunnel source IP address.","title":"VXLAN Interfaces"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#vrfs","text":"auto xal-001 iface xal-001 vrf-table auto auto xal-002 iface xal-002 vrf-table auto vrf-table auto table id is automatically assigned","title":"VRFs"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#routing","text":"","title":"Routing"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#bgp","text":"","title":"BGP"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#overlay-and-underlay","text":"The BGP process on the spines needs to retain information it receives about both the overlay and the underlay. It uses the underlay information to build the underlay packet forwarding table. It needs to retain the overlay information it receives from a leaf to pass it to the other leaves (functioning like a RR). However, the spines don\u2019t know anything about virtual networks and will drop the information about them unless otherwise instructed. FRR automatically makes the spines keep that information when it recognizes that the same session is used for carrying both underlay and overlay routes. In other vendor implementations that support a single eBGP session model, additional configuration might need to be added.","title":"Overlay and underlay"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#unnumbered-bgp","text":"","title":"Unnumbered BGP"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#ipv6-link-local-address","text":"When enabled on a link, IPv6 automatically generates an IPv6 address that is valid only on that link, a link-local address (LLA). Most often, the interface MAC address is used to generate the address. IPv6 LLAs have a well-defined format: they start with fe80. An example of an IPv6 LLA is fe80::5054:ff:fe6d:4cbe. Unnumbered BGP uses this LLA to set up the TCP connection. Instead of asking the user to specify this, FRR uses the interface name to understand that the user wants to use the IPv6 LLA to establish the BGP peering. So, if fe80::5054:ff:fe6d:4cbe is the IPv6 LLA of the interface, FRR expects to receive a connect request on that address from the peer on that interface. Alternatively, it uses that address to send the connect request to the peer. However, to establish a connection with a remote entity, BGP needs the IPv6 LLA of the interface on the other end of the link. How does a node get that automatically? Via IPv6 router advertisement.","title":"IPv6 link-local address"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#ipv6-router-advertisement","text":"To allow hosts and routers to automatically discover neighboring routers, IPv6 designers added router advertisement (RA). RA is one of the messages used in IPv6\u2019s NDP. IPv6 NDP is the IPv6 equivalent of IPv4\u2019s ARP. When enabled on an interface, RA periodically announces the interface\u2019s IPv6 addresses, including the LLA. Thus, one end can automatically determine the other end\u2019s IPv6 address. Like IPv6, RA is universally implemented these days on both hosts and routers. The IPv6 LLA is used only to establish a TCP connection for starting a BGP session. Besides enabling IPv6 on a link, which is typically enabled automatically, and the enabling of the IPv6 router advertisement on the link, no other knowledge of IPv6 is expected of the operator.","title":"IPv6 router advertisement"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#rfc-5549","text":"Establishing a TCP connection over IPv6 LLA isn\u2019t enough. To exchange IPv4 routes, we need a next-hop IPv4 address. But the interface on which BGP peering has been established has no IPv4 address and there is no other reachable IPv4 address for the router to advertise. So how does this work? There are two parts to this: a control-plane part and a packet forwarding (or data plane) part. The control-plane part involves implementing a standard, well-defined extension to encoding BGP\u2019s next-hop value. That standard is defined in RFC 5549, which is titled \u201cAdvertising IPv4 Network Layer Reachability Information with an IPv6 Next Hop.\u201d Remember, an IPv4 NLRI is just the route. So, this RFC defines how to advertise an IPv4 route with a next-hop IPv6 address. As with any other BGP extension, the support for encoding and processing an IPv4 route with an IPv6 next hop is first negotiated as part of the capability exchange in the BGP OPEN message. Only if both sides of a peering session support this capability is this method of advertising IPv4 routes with IPv6 next hop used. The BGP capability to indicate support for RFC 5549 is called extended next hop. The IPv6 RA gives us not only the link-local IPv6 address of the peer router, but also the MAC address of the peer interface on that router. So, for any given IPv6 link local address, we have its corresponding MAC address. Packet-switching silicon typically has a route pointing to a group of next hops, and each entry in the next hop only contains the MAC address (and VLAN). So the packet-switching silicon\u2019s routing table can be populated with an IPv4 route with the next-hop MAC address with this information. Thus, the information from the RFC 5549 encoding can be used to populate the packet-switching silicon just as if we had received an IPv4 route with an IPv4 next-hop address.","title":"RFC 5549"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#rfc-5549-with-frr","text":"The next-hop router\u2019s IP address is needed for only one trivial thing: it appears in the output of commands displaying the route. You can work around this by using a dummy IPv4 address. FRR uses 169.254.0.1 as this dummy IPv4 address.","title":"RFC 5549 with FRR"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#how-frr-implements-unnumbered-bgp","text":"FRR implements IPv6 RA natively. FRR\u2019s RA when enabled on an interface announces its own LLA and MAC address. RA packets are used with a link-local multicast address and so they\u2019re never forwarded. On receiving an RA packet from a peer router on an interface, FRR\u2019s RA extracts the MAC address and the associated IPv6 LLA. Now that the interface\u2019s peering address is known, FRR kicks BGP into action to start connection establishment using the learned IPv6 LLA. After a successful BGP connection establishment, BGP uses capability negotiation to ensure that both sides of the peering session support RFC 5549. BGP receives a route advertisement for a route, say 10.0.0.11/32, from the peer with the peer\u2019s IPv6 LLA (and global IPv6 address if one is configured). If BGP selects this path as the best path to reach 10.0.0.11/32, it passes this route down to the RIB process (called zebra in FRR), with the next hop set to the IPv6 LLA received in the BGP UPDATE message. Let\u2019s assume the RIB picks this BGP route as the best route with which to populate the FIB. The RIB process now consults its database to see whether it has the information for the MAC address associated with this IPv6 LLA. It sees that there is such an entry. The RIB process now adds a static ARP entry for 169.254.0.1 with this MAC address, with the peering interface as the outgoing interface. The RIB process then pushes the route into the kernel routing table with a next hop of 169.254.0.1 and an outgoing interface set to that of the peering interface. interface {{ swp.name }} ipv6 nd ra-interval 5 no ipv6 nd suppress-ra ! router bgp 65011 bgp router-id 10.0.0.11 neighbor ISL capability extended-nexthop When you specify neighbor swp1 interface..., FRR assumes that you\u2019re using unnumbered BGP, enables RA automatically on that interface, and advertises the capability in the BGP peering session over that interface.","title":"How FRR implements Unnumbered BGP"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#frr-configuration","text":"router bgp 4213010101 bgp router-id 10.136.128.3 bgp bestpath as-path multipath-relax bgp bestpath compare-routerid neighbor FABRIC peer-group neighbor FABRIC remote-as external neighbor FABRIC bfd 5 200 200 neighbor swp15 interface peer-group FABRIC neighbor swp16 interface peer-group FABRIC ! address-family ipv4 unicast redistribute connected route-map rm_LOOPBACK_ONLY neighbor FABRIC activate exit-address-family ! address-family ipv6 unicast redistribute connected route-map rm_LOOPBACK_ONLY neighbor FABRIC activate exit-address-family ! address-family l2vpn evpn neighbor FABRIC activate advertise-all-vni advertise ipv4 unicast advertise ipv6 unicast exit-address-family ! address-family l2vpn evpn activates EVPN","title":"FRR Configuration"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#peer-group","text":"To simplify repetition when configuring multiple neighbors, most routing suites support a form of templating called peer group. The user creates a peer group with a name and then proceeds to configure the desired attributes for neighbor connection (such as remote-as, connection timers, and the use of BFD). In the next step, the operator assigns each real neighbor to the created peer group, thus avoiding the need to type the same boring stuff over and over again.","title":"Peer Group"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#routing-policy","text":"Routing policy, at its simplest, specifies when to accept or reject route advertisements. Based on where they\u2019re used, the accept or reject could apply to routes received from a peer, routes advertised to a peer, and redistributed routes. A routing policy consists of a sequence of if-then-else statements, with matches and actions to be taken on a successful match.","title":"Routing policy"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#route-maps","text":"Route maps are a common way to implement routing policies. {# default route maps and prefix lists#} {{''}} ip prefix-list pl_DEFAULT_ONLY_4 seq 10 permit 0.0.0.0/0 ip prefix-list pl_DEFAULT_ONLY_4 seq 20 deny any ! ipv6 prefix-list pl_DEFAULT_ONLY_6 seq 10 permit ::/0 ipv6 prefix-list pl_DEFAULT_ONLY_6 seq 20 deny any ! route-map rm_DEFAULT_ONLY_4 permit 10 match ip address prefix-list pl_DEFAULT_ONLY_4 ! route-map rm_DEFAULT_ONLY_4 deny 20 ! route-map rm_DEFAULT_ONLY_6 permit 10 match ipv6 address prefix-list pl_DEFAULT_ONLY_6 ! route-map rm_DEFAULT_ONLY_6 deny 20 ! route-map rm_LOOPBACK_ONLY permit 10 match interface lo ! route-map rm_LOOPBACK_ONLY deny 20 !","title":"Route Maps"},{"location":"Network/Cumulus/Cumulus%20Fabric%20with%20VXLAN%20EVPN%20%26%20BGP/#firewalling","text":"The border leaves have interfaces to a firewall. One connection belongs to the green VRF and the other to the black VRF. The firewalls have two BGP sessions: one over the green subinterface and one over the black interface. The firewall just readvertise the routes learned via the green link to the BGP session over the black link, and vice versa. Thus, the default route learned by the border router via the internet router is sent to the firewall via the black link. The firewall readvertises this over the green link BGP session. From the perspective of traffic traversing form the internal to the external network, traffic now automatically flows through the firewall.","title":"Firewalling"},{"location":"Network/Cumulus/NVIDIA%20AIR/","text":"NVIDIA AIR \u2691 SSH Configuration \u2691 Host nvidia-air HostName worker04.air.nvidia.com Port 24580 User cumulus StrictHostKeyChecking no Host leaf0* spine0* border0* server0* ProxyJump nvidia-air User cumulus StrictHostKeyChecking no","title":"NVIDIA AIR"},{"location":"Network/Cumulus/NVIDIA%20AIR/#nvidia-air","text":"","title":"NVIDIA AIR"},{"location":"Network/Cumulus/NVIDIA%20AIR/#ssh-configuration","text":"Host nvidia-air HostName worker04.air.nvidia.com Port 24580 User cumulus StrictHostKeyChecking no Host leaf0* spine0* border0* server0* ProxyJump nvidia-air User cumulus StrictHostKeyChecking no","title":"SSH Configuration"},{"location":"Network/EVE-NG/KVM%20Setup/","text":"KVM Setup for EVE-NG \u2691 Setup networking \u2691 To make everything a bit easier a bridge network can be created with the linked guide Bridge Interface .","title":"KVM Setup for EVE-NG"},{"location":"Network/EVE-NG/KVM%20Setup/#kvm-setup-for-eve-ng","text":"","title":"KVM Setup for EVE-NG"},{"location":"Network/EVE-NG/KVM%20Setup/#setup-networking","text":"To make everything a bit easier a bridge network can be created with the linked guide Bridge Interface .","title":"Setup networking"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/","text":"Deploy VXLAN & EVPN with FRR \u2691 Topology used: Local Configuration \u2691 leaf01 \u2691 au t o all i fa ce lo i net loopback address 10.0.0.11 / 32 clagd - vxla n - a n ycas t - ip 10.0.0.112 vxla n - local - tunnel ip 10.0.0.11 i fa ce v n i 13 m tu 9164 vxla n - id 13 bridge - access 13 bridge - lear n i n g o ff i fa ce v n i 24 m tu 9164 vxla n - id 24 bridge - access 24 bridge - lear n i n g o ff i fa ce vla n 13 m tu 9164 address 172.16.1.11 / 24 address - vir tual 44 : 39 : 39 : ff : 00 : 13 172.168.1.1 / 24 vla n - id 13 vla n - raw - device - bridge vr f evp n - vr f i fa ce vla n 24 m tu 9164 address 172.16.2.11 / 24 address - vir tual 44 : 39 : 39 : ff : 00 : 13 172.168.2.1 / 24 vla n - id 24 vla n - raw - device - bridge vr f evp n - vr f # This is t he L 3 VNI de f i n i t io n t ha t we nee d f or symme tr ic co nf igura t io n . # This is used t o trans por t t he EVPN - rou te d packe t be t wee n t he VTEPs. i fa ce vxla n 4001 vxla n - id 104001 vla n - raw - device - bridge i fa ce vla n 4001 hwaddress 44 : 39 : 39 : FF : 40 : 94 vla n - id 4001 vla n - raw - device - bridge vr f evp n - vr f clagd-vxlan-anycast-ip 10.0.0.112 configures the Cumulus-specific MLAG implementation, CLAG, by defining the shared VXLAN source tunnel's IP address. This is required because of the dual-attached servers. vxlan-local-tunnelip 10.0.0.11 specifies the local source tunnel IP address to be used when CLAG isn't operational. When CLAG is operational, the address specified with clagd-vxlan-anycast-ip is used as the tunnel source IP address. iface vni 13 each VXLAN VNI is represented by a device in the Linux kernel. mtu 9164 VXLAN tunnel interfaces recommend using jumbo frames, so we set the MTU of the interface to 9164 bridge-access maps the VNI to a local VLAN ID bridge-learning off because we don't want to enable learning of remote MAC addresses because we have EVPN. So we disable learning on the VNIs iface vlan13 this defines the SVI for the VNIs - these are the VNIs for which the node supports routing address 172.16.1.11/24 the unique IP address of this leaf on the specified VNI address-virtual 44:39:39:ff:00:13 172.168.1.1/24 this is the secondary gateway IP address for the VNI. The address is shared across all the leaves that carry this VNI. Servers are configured to use this IP address as the default gateway address to allow a server to be attached to any rack and not have to change its default gateway configuration vlan-raw-device-bridge Linux allows the presence of multiple 802.1Q bridges on the same device. An interface is assigned to only one of the bridges and so there is no ambiguity on the link about the use of a VLAN. iface vxlan4001 this is the L3 VNI used in symmetric routing iface vlan4001 this is merely the local instantiation of the L3 VNI exit01 \u2691 interface lo ip address 10.0.0.101/32 ! interface swp3 ip address 169.254.127.1/31 ! interface swp4.2 ip address 169.254.254.1/31 ! interface swp4.3 ip address 169.254.254.3/31 ! interface swp4.4 ip address 169.254.254.5/31 ! vrf evpn-vrf vni 104001 ! ! default VRF peering with the underlay and the firewall Single eBGP Session \u2691 spine01 \u2691 interface lo ip address 10.0.0.21/32 ! router bgp 65000 bgp router-id 10.0.0.21 bgp bestpath as-path multipath-relax neighbor peer-group ISL neighbor ISL remote-as external neighbor swp1 interface peer-group ISL neighbor swp2 interface peer-group ISL neighbor swp3 interface peer-group ISL neighbor swp4 interface peer-group ISL neighbor swp5 interface peer-group ISL neighbor swp6 interface peer-group ISL address-family ipv4 unicast neighbor ISL activate redistribute connected route-map LOOPBACKS address-family l2vpn evpn neighbor ISL activate ! route-map LOOPBACKS permit 10 match interface lo address-family l2vpn evpn activates the l2vpn evpn address family to signal to its peers that it can process EVPN routes. This is not an indication that the spine is participating in the overlay. Required on all nodes that exchange EVPN information. leaf01 \u2691 interface lo ip address 10.0.0.11/32 ! ! This VRF definition is needed only for symmetric EVPN routing vrf evpn-vrf vni 104001 ! router bgp 65011 bgp router-id 10.0.0.11 bgp bestpath as-path multipath-relax neighbor fabric peer-group neighbor fabric remote-as external neighbor swp1 interface peer-group fabric neighbor swp2 interface peer-group fabric address-family ipv4 unicast neighbor fabric activate redistribute connected route-map LOOPBACKS ! address-family l2vpn evpn neighbor fabric activate advertise-all-vni advertise-svi-ip ! ! route-map LOOPBACKS permit 10 match interface lo ! vrf evpn-vrf this VRF definition is what distinguishes symmetric routing configuration from asymmetric routing in the configuration. This definition specifies the L3 VNI used by a VRF. Think of this mapping as the equivalent of the VLAN-VNI mapping. advertise-all-vni enables advertisement of EVPN information, specifically RT-2 and RT-3 routes. This is present only on leaves (border or normal). advertise-svi-ip needed for individual leaves to run ping, traceroute from the leaves on the evpn-vrf. exit01 \u2691 router bgp 65201 bgp router-id 10.0.0.101 bgp bestpath as-path multipath-relax neighbor fabric peer-group neighbor fabric remote-as external ! These two are peering with the spine neighbor swp1 interface peer-group fabric neighbor swp2 interface peer-group fabric ! This is peering with the firewall to announce the underlay ! routes to the edge router (via the firewall) and receive the ! default route from the edge router (also via the firewall) neighbor swp4.2 interface remote-as external address-family ipv4 unicast neighbor fabric activate neighbor swp4.2 activate neighbor swp4.2 allowas-in 1 redistribute connected route-map LOOPBACKS ! address-family l2vpn evpn neighbor fabric activate advertise-all-vni ! ! route-map LOOPBACKS permit 10 match interface lo ! ! evpn vrf peering to announce default route to internal net ! router bgp 65201 vrf evpn-vrf bgp router-id 10.0.0.101 neighbor swp4.3 interface remote-as external address-family ipv4 unicast neighbor swp4.3 activate ! The following two network statements are for ! distributing the summarized route to the firewall aggregate-address 172.16.1.0/24 summary-only aggregate-address 172.16.2.0/24 summary-only neighbor swp4.3 allowas-in 1 exit-address-family ! ! This config ensures we advertise the default route ! as a type 5 route in EVPN in the main BGP instance. ! The firewall peering is to get the default route ! in the evpn-vrf from the internet-vrf. Firewall ! does not peer for l2vpn/evpn. ! address-family l2vpn evpn advertise ipv4 unicast ! ! internet vrf peering to retrieve the default route from the ! internet facing router and give it to the firewall. ! router bgp 65201 vrf internet-vrf bgp router-id 10.0.0.101 bgp bestpath as-path multipath-relax neighbor internet peer-group neighbor internet remote-as external neighbor swp4.4 interface peer-group internet neighbor swp3 interface peer-group internet address-family ipv4 unicast neighbor internet activate neighbor swp4.4 allowas-in 1 neighbor swp3 remove-private-AS redistribute connected route-map INTERNET ! ! route-map INTERNET permit 10 match interface internet-vrf ! router bgp 65201 this section deals with the underlay and the receiving of EVPN routes from the rest of the leaves. It also peers with the firewall to ensure that the underlay gets the default route. router bgp 65201 vrf evpn-vrf this VRF configuration on the exit leaf is required to advertise the default route in the evpn-vrf VRF. aggregate-address 172.16.1.0/24 summary-only instructs BGP to announce only the summarized route and do so only if there's at least one route in that subnet. address-family l2vpn evpn advertises the default route as an RT-5 EVPN route. No activate statement is required, because there are no neighbors with whom EVPN routes are to be exchanged in this VRF. The RT-5 route is announced in the underlay BGP session. router bgp 65201 vrf internet-vrf VRF configuration to interface with the edge route in the internet-vrf for connectivity to the outside world. The internet-vrf has no EVPN configuration, so there is no need to define an L3 VNI for the internet-vrf. neighbor swp3 remove-private-AS strips off all private ASNs before advertising the routes to the edge router. When VXLAN is the virtual network overlay, BGP doesn't require any per-VRF peering, because the VNI in the packet encodes this information. VXLAN Setup \u2691 Each VXLAN is locally configured using a bridge for local virtual interfaces, like illustrated in the below schema. The bridge is taking care of the local MAC addresses (notably, using source-address learning) and the VXLAN interface takes care of the remote MAC addresses (received with BGP EVPN). VXLANs can be provisioned with the following script. Source-address learning is disabled as we will rely solely on BGP EVPN to synchronize FDBs between the hypervisors. for vni in 100 200; do # Create VXLAN interface ip link add vxlan${vni} type vxlan id ${vni} \\ dstport 4789 \\ local 203.0.113.2 \\ nolearning # Create companion bridge brctl addbr br${vni} brctl addif br${vni} vxlan${vni} brctl stp br${vni} off ip link set up dev br${vni} ip link set up dev vxlan${vni} done # Attach each VM to the appropriate segment brctl addif br100 vnet10 brctl addif br100 vnet11 brctl addif br200 vnet12 The configuration of FRR is similar to the one used for a route reflector, except we use the advertise-all-vni directive to publish all local VNIs. router bgp 65000 bgp router-id 203.0.113.2 no bgp default ipv4-unicast neighbor fabric peer-group neighbor fabric remote-as 65000 neighbor fabric capability extended-nexthop ! BGP sessions with route reflectors neighbor 203.0.113.253 peer-group fabric neighbor 203.0.113.254 peer-group fabric ! address-family l2vpn evpn neighbor fabric activate advertise-all-vni exit-address-family ! ! FRR should also be able to retrieve information about the local MAC addresses. Each VTEP has to establish a BGP session with the route reflectors. BGP EVPN (Ethernet Virtual Private Network) \u2691 Route reflector setup using FRR \u2691 The configuration is pretty simple. We suppose the configured route reflector has 203.0.113.254 configured as a loopback IP. rou ter bgp 65000 bgp rou ter - id 203.0.113.254 bgp clus ter - id 203.0.113.254 bgp log - ne ighbor - cha n ges n o bgp de fault ipv 4- u n icas t ne ighbor fa bric peer - group ne ighbor fa bric remo te - as 65000 ne ighbor fa bric capabili t y ex ten ded - ne x t hop ne ighbor fa bric upda te - source 203.0.113.254 bgp lis ten ra n ge 203.0.113.0 / 24 peer - group fa bric ! address - fa mily l 2 vp n evp n ne ighbor fa bric ac t iva te ne ighbor fa bric rou te - re fle c t or - clie nt exi t - address - fa mily ! ! A peer group fabric is defined and we leverage the dynamic neighbor feature of FRR: we don\u2019t have to explicitly define each neighbor. Any client from 203.0.113.0/24 and presenting itself as part of AS\u202f65000 can connect. All sent EVPN routes will be accepted and reflected to the other clients. Using Junos \u2691 i nterfa ces { lo 0 { u n i t 0 { fa mily i net { address 203.0.113.254 / 32 ; } } } } pro t ocols { bgp { group fa bric { fa mily evp n { sig nal i n g { /* Do n o t tr y t o i nstall EVPN rou tes */ n o - i nstall ; } } t ype i nternal ; clus ter 203.0.113.254 ; local - address 203.0.113.254 ; allow 203.0.113.0 / 24 ; } } } rou t i n g - op t io ns { rou ter - id 203.0.113.254 ; au t o n omous - sys te m 65000 ; } ARP suppression \u2691","title":"Deploy VXLAN & EVPN with FRR"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#deploy-vxlan-evpn-with-frr","text":"Topology used:","title":"Deploy VXLAN &amp; EVPN with FRR"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#local-configuration","text":"","title":"Local Configuration"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#leaf01","text":"au t o all i fa ce lo i net loopback address 10.0.0.11 / 32 clagd - vxla n - a n ycas t - ip 10.0.0.112 vxla n - local - tunnel ip 10.0.0.11 i fa ce v n i 13 m tu 9164 vxla n - id 13 bridge - access 13 bridge - lear n i n g o ff i fa ce v n i 24 m tu 9164 vxla n - id 24 bridge - access 24 bridge - lear n i n g o ff i fa ce vla n 13 m tu 9164 address 172.16.1.11 / 24 address - vir tual 44 : 39 : 39 : ff : 00 : 13 172.168.1.1 / 24 vla n - id 13 vla n - raw - device - bridge vr f evp n - vr f i fa ce vla n 24 m tu 9164 address 172.16.2.11 / 24 address - vir tual 44 : 39 : 39 : ff : 00 : 13 172.168.2.1 / 24 vla n - id 24 vla n - raw - device - bridge vr f evp n - vr f # This is t he L 3 VNI de f i n i t io n t ha t we nee d f or symme tr ic co nf igura t io n . # This is used t o trans por t t he EVPN - rou te d packe t be t wee n t he VTEPs. i fa ce vxla n 4001 vxla n - id 104001 vla n - raw - device - bridge i fa ce vla n 4001 hwaddress 44 : 39 : 39 : FF : 40 : 94 vla n - id 4001 vla n - raw - device - bridge vr f evp n - vr f clagd-vxlan-anycast-ip 10.0.0.112 configures the Cumulus-specific MLAG implementation, CLAG, by defining the shared VXLAN source tunnel's IP address. This is required because of the dual-attached servers. vxlan-local-tunnelip 10.0.0.11 specifies the local source tunnel IP address to be used when CLAG isn't operational. When CLAG is operational, the address specified with clagd-vxlan-anycast-ip is used as the tunnel source IP address. iface vni 13 each VXLAN VNI is represented by a device in the Linux kernel. mtu 9164 VXLAN tunnel interfaces recommend using jumbo frames, so we set the MTU of the interface to 9164 bridge-access maps the VNI to a local VLAN ID bridge-learning off because we don't want to enable learning of remote MAC addresses because we have EVPN. So we disable learning on the VNIs iface vlan13 this defines the SVI for the VNIs - these are the VNIs for which the node supports routing address 172.16.1.11/24 the unique IP address of this leaf on the specified VNI address-virtual 44:39:39:ff:00:13 172.168.1.1/24 this is the secondary gateway IP address for the VNI. The address is shared across all the leaves that carry this VNI. Servers are configured to use this IP address as the default gateway address to allow a server to be attached to any rack and not have to change its default gateway configuration vlan-raw-device-bridge Linux allows the presence of multiple 802.1Q bridges on the same device. An interface is assigned to only one of the bridges and so there is no ambiguity on the link about the use of a VLAN. iface vxlan4001 this is the L3 VNI used in symmetric routing iface vlan4001 this is merely the local instantiation of the L3 VNI","title":"leaf01"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#exit01","text":"interface lo ip address 10.0.0.101/32 ! interface swp3 ip address 169.254.127.1/31 ! interface swp4.2 ip address 169.254.254.1/31 ! interface swp4.3 ip address 169.254.254.3/31 ! interface swp4.4 ip address 169.254.254.5/31 ! vrf evpn-vrf vni 104001 ! ! default VRF peering with the underlay and the firewall","title":"exit01"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#single-ebgp-session","text":"","title":"Single eBGP Session"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#spine01","text":"interface lo ip address 10.0.0.21/32 ! router bgp 65000 bgp router-id 10.0.0.21 bgp bestpath as-path multipath-relax neighbor peer-group ISL neighbor ISL remote-as external neighbor swp1 interface peer-group ISL neighbor swp2 interface peer-group ISL neighbor swp3 interface peer-group ISL neighbor swp4 interface peer-group ISL neighbor swp5 interface peer-group ISL neighbor swp6 interface peer-group ISL address-family ipv4 unicast neighbor ISL activate redistribute connected route-map LOOPBACKS address-family l2vpn evpn neighbor ISL activate ! route-map LOOPBACKS permit 10 match interface lo address-family l2vpn evpn activates the l2vpn evpn address family to signal to its peers that it can process EVPN routes. This is not an indication that the spine is participating in the overlay. Required on all nodes that exchange EVPN information.","title":"spine01"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#leaf01_1","text":"interface lo ip address 10.0.0.11/32 ! ! This VRF definition is needed only for symmetric EVPN routing vrf evpn-vrf vni 104001 ! router bgp 65011 bgp router-id 10.0.0.11 bgp bestpath as-path multipath-relax neighbor fabric peer-group neighbor fabric remote-as external neighbor swp1 interface peer-group fabric neighbor swp2 interface peer-group fabric address-family ipv4 unicast neighbor fabric activate redistribute connected route-map LOOPBACKS ! address-family l2vpn evpn neighbor fabric activate advertise-all-vni advertise-svi-ip ! ! route-map LOOPBACKS permit 10 match interface lo ! vrf evpn-vrf this VRF definition is what distinguishes symmetric routing configuration from asymmetric routing in the configuration. This definition specifies the L3 VNI used by a VRF. Think of this mapping as the equivalent of the VLAN-VNI mapping. advertise-all-vni enables advertisement of EVPN information, specifically RT-2 and RT-3 routes. This is present only on leaves (border or normal). advertise-svi-ip needed for individual leaves to run ping, traceroute from the leaves on the evpn-vrf.","title":"leaf01"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#exit01_1","text":"router bgp 65201 bgp router-id 10.0.0.101 bgp bestpath as-path multipath-relax neighbor fabric peer-group neighbor fabric remote-as external ! These two are peering with the spine neighbor swp1 interface peer-group fabric neighbor swp2 interface peer-group fabric ! This is peering with the firewall to announce the underlay ! routes to the edge router (via the firewall) and receive the ! default route from the edge router (also via the firewall) neighbor swp4.2 interface remote-as external address-family ipv4 unicast neighbor fabric activate neighbor swp4.2 activate neighbor swp4.2 allowas-in 1 redistribute connected route-map LOOPBACKS ! address-family l2vpn evpn neighbor fabric activate advertise-all-vni ! ! route-map LOOPBACKS permit 10 match interface lo ! ! evpn vrf peering to announce default route to internal net ! router bgp 65201 vrf evpn-vrf bgp router-id 10.0.0.101 neighbor swp4.3 interface remote-as external address-family ipv4 unicast neighbor swp4.3 activate ! The following two network statements are for ! distributing the summarized route to the firewall aggregate-address 172.16.1.0/24 summary-only aggregate-address 172.16.2.0/24 summary-only neighbor swp4.3 allowas-in 1 exit-address-family ! ! This config ensures we advertise the default route ! as a type 5 route in EVPN in the main BGP instance. ! The firewall peering is to get the default route ! in the evpn-vrf from the internet-vrf. Firewall ! does not peer for l2vpn/evpn. ! address-family l2vpn evpn advertise ipv4 unicast ! ! internet vrf peering to retrieve the default route from the ! internet facing router and give it to the firewall. ! router bgp 65201 vrf internet-vrf bgp router-id 10.0.0.101 bgp bestpath as-path multipath-relax neighbor internet peer-group neighbor internet remote-as external neighbor swp4.4 interface peer-group internet neighbor swp3 interface peer-group internet address-family ipv4 unicast neighbor internet activate neighbor swp4.4 allowas-in 1 neighbor swp3 remove-private-AS redistribute connected route-map INTERNET ! ! route-map INTERNET permit 10 match interface internet-vrf ! router bgp 65201 this section deals with the underlay and the receiving of EVPN routes from the rest of the leaves. It also peers with the firewall to ensure that the underlay gets the default route. router bgp 65201 vrf evpn-vrf this VRF configuration on the exit leaf is required to advertise the default route in the evpn-vrf VRF. aggregate-address 172.16.1.0/24 summary-only instructs BGP to announce only the summarized route and do so only if there's at least one route in that subnet. address-family l2vpn evpn advertises the default route as an RT-5 EVPN route. No activate statement is required, because there are no neighbors with whom EVPN routes are to be exchanged in this VRF. The RT-5 route is announced in the underlay BGP session. router bgp 65201 vrf internet-vrf VRF configuration to interface with the edge route in the internet-vrf for connectivity to the outside world. The internet-vrf has no EVPN configuration, so there is no need to define an L3 VNI for the internet-vrf. neighbor swp3 remove-private-AS strips off all private ASNs before advertising the routes to the edge router. When VXLAN is the virtual network overlay, BGP doesn't require any per-VRF peering, because the VNI in the packet encodes this information.","title":"exit01"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#vxlan-setup","text":"Each VXLAN is locally configured using a bridge for local virtual interfaces, like illustrated in the below schema. The bridge is taking care of the local MAC addresses (notably, using source-address learning) and the VXLAN interface takes care of the remote MAC addresses (received with BGP EVPN). VXLANs can be provisioned with the following script. Source-address learning is disabled as we will rely solely on BGP EVPN to synchronize FDBs between the hypervisors. for vni in 100 200; do # Create VXLAN interface ip link add vxlan${vni} type vxlan id ${vni} \\ dstport 4789 \\ local 203.0.113.2 \\ nolearning # Create companion bridge brctl addbr br${vni} brctl addif br${vni} vxlan${vni} brctl stp br${vni} off ip link set up dev br${vni} ip link set up dev vxlan${vni} done # Attach each VM to the appropriate segment brctl addif br100 vnet10 brctl addif br100 vnet11 brctl addif br200 vnet12 The configuration of FRR is similar to the one used for a route reflector, except we use the advertise-all-vni directive to publish all local VNIs. router bgp 65000 bgp router-id 203.0.113.2 no bgp default ipv4-unicast neighbor fabric peer-group neighbor fabric remote-as 65000 neighbor fabric capability extended-nexthop ! BGP sessions with route reflectors neighbor 203.0.113.253 peer-group fabric neighbor 203.0.113.254 peer-group fabric ! address-family l2vpn evpn neighbor fabric activate advertise-all-vni exit-address-family ! ! FRR should also be able to retrieve information about the local MAC addresses. Each VTEP has to establish a BGP session with the route reflectors.","title":"VXLAN Setup"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#bgp-evpn-ethernet-virtual-private-network","text":"","title":"BGP EVPN (Ethernet Virtual Private Network)"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#route-reflector-setup-using-frr","text":"The configuration is pretty simple. We suppose the configured route reflector has 203.0.113.254 configured as a loopback IP. rou ter bgp 65000 bgp rou ter - id 203.0.113.254 bgp clus ter - id 203.0.113.254 bgp log - ne ighbor - cha n ges n o bgp de fault ipv 4- u n icas t ne ighbor fa bric peer - group ne ighbor fa bric remo te - as 65000 ne ighbor fa bric capabili t y ex ten ded - ne x t hop ne ighbor fa bric upda te - source 203.0.113.254 bgp lis ten ra n ge 203.0.113.0 / 24 peer - group fa bric ! address - fa mily l 2 vp n evp n ne ighbor fa bric ac t iva te ne ighbor fa bric rou te - re fle c t or - clie nt exi t - address - fa mily ! ! A peer group fabric is defined and we leverage the dynamic neighbor feature of FRR: we don\u2019t have to explicitly define each neighbor. Any client from 203.0.113.0/24 and presenting itself as part of AS\u202f65000 can connect. All sent EVPN routes will be accepted and reflected to the other clients.","title":"Route reflector setup using FRR"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#using-junos","text":"i nterfa ces { lo 0 { u n i t 0 { fa mily i net { address 203.0.113.254 / 32 ; } } } } pro t ocols { bgp { group fa bric { fa mily evp n { sig nal i n g { /* Do n o t tr y t o i nstall EVPN rou tes */ n o - i nstall ; } } t ype i nternal ; clus ter 203.0.113.254 ; local - address 203.0.113.254 ; allow 203.0.113.0 / 24 ; } } } rou t i n g - op t io ns { rou ter - id 203.0.113.254 ; au t o n omous - sys te m 65000 ; }","title":"Using Junos"},{"location":"Network/FRR/Deploy%20VXLAN%20%26%20EVPN/#arp-suppression","text":"","title":"ARP suppression"},{"location":"Network/General/NETCONF/","text":"Overview \u2691 Provides a standard connection protocol to communicate with network devices. Layers \u2691 Messages Layer \u2691 <rpc> \u2691 The <rpc> element encapsulates all remote procedure calls to the NETCONF server. This includes both operational mode and configuration RPCs. <rpc-reply> \u2691 The <rpc-reply> element encapsulates all remote procedure call replies from the NETCONF server. This includes data returned from the NETCONF server and any 0K. error or warning messages. <notification> \u2691 The <notification> element is a one-way message and is sent to the client who initiated a <create-subscription> command when an event of interest has occurred. Operations Layer \u2691 <lock> <unlock> <get> <get-config> <edit-config> <copy-config> <commit> <discard-changes> <delete-config> <validate> <create-subscription> <close-session> <kill-session> Content Layer \u2691 Contains RPC request and response payload Contains configuration data","title":"Overview"},{"location":"Network/General/NETCONF/#overview","text":"Provides a standard connection protocol to communicate with network devices.","title":"Overview"},{"location":"Network/General/NETCONF/#layers","text":"","title":"Layers"},{"location":"Network/General/NETCONF/#messages-layer","text":"","title":"Messages Layer"},{"location":"Network/General/NETCONF/#rpc","text":"The <rpc> element encapsulates all remote procedure calls to the NETCONF server. This includes both operational mode and configuration RPCs.","title":"&lt;rpc&gt;"},{"location":"Network/General/NETCONF/#rpc-reply","text":"The <rpc-reply> element encapsulates all remote procedure call replies from the NETCONF server. This includes data returned from the NETCONF server and any 0K. error or warning messages.","title":"&lt;rpc-reply&gt;"},{"location":"Network/General/NETCONF/#notification","text":"The <notification> element is a one-way message and is sent to the client who initiated a <create-subscription> command when an event of interest has occurred.","title":"&lt;notification&gt;"},{"location":"Network/General/NETCONF/#operations-layer","text":"<lock> <unlock> <get> <get-config> <edit-config> <copy-config> <commit> <discard-changes> <delete-config> <validate> <create-subscription> <close-session> <kill-session>","title":"Operations Layer"},{"location":"Network/General/NETCONF/#content-layer","text":"Contains RPC request and response payload Contains configuration data","title":"Content Layer"},{"location":"Network/General/OSI-Layers/OSI%20Layer-1/","text":"Overview OSI Layer-1 \u2691 Layer 1 is anything that carries 1\u2019s and 0\u2019s between two nodes. The actual format of the data on the \u201cwire\u201d can vary with each medium. In the case of Ethernet, bits are transferred in the form of electric pulses. In the case of Wifi, bits are transferred in the form of radio waves. In the case of Fiber, bits are transferred in the form of pulses of light. A Repeater simply repeats a signal from one medium to the other, allowing a series of cables to be daisy chained together and increase the range a signal can travel beyond the single cable limit. These are commonly used in large WiFi deployments, where a single WiFi network is \u201crepeated\u201d throughout multiple access-points to cover a larger range. A Hub is simply a multi-port Repeater. If four devices are connected to a single Hub, anything sent by one device gets repeated to the other three.","title":"Overview OSI Layer-1"},{"location":"Network/General/OSI-Layers/OSI%20Layer-1/#overview-osi-layer-1","text":"Layer 1 is anything that carries 1\u2019s and 0\u2019s between two nodes. The actual format of the data on the \u201cwire\u201d can vary with each medium. In the case of Ethernet, bits are transferred in the form of electric pulses. In the case of Wifi, bits are transferred in the form of radio waves. In the case of Fiber, bits are transferred in the form of pulses of light. A Repeater simply repeats a signal from one medium to the other, allowing a series of cables to be daisy chained together and increase the range a signal can travel beyond the single cable limit. These are commonly used in large WiFi deployments, where a single WiFi network is \u201crepeated\u201d throughout multiple access-points to cover a larger range. A Hub is simply a multi-port Repeater. If four devices are connected to a single Hub, anything sent by one device gets repeated to the other three.","title":"Overview OSI Layer-1"},{"location":"Network/General/OSI-Layers/OSI%20Layer-2/","text":"Overview OSI Layer-2 \u2691 The Data Link layer of the OSI model is responsible for interfacing with the Physical layer. Effectively, Layer 2 is responsible for putting 1\u2019s and 0\u2019s on the wire, and pulling 1\u2019s and 0\u2019s from the wire. The Network Interface Card (NIC) that you plug your Ethernet wire into handles the Layer 2 functionality. It receives signals from the wire, and transmits signals on to the wire. Your WiFi NIC works the same way, receiving and transmitting radio waves which are then interpreted as a series of 1\u2019s and 0\u2019s. Layer 2 will then group together those 1\u2019s and 0\u2019s into chunks known as Frames.","title":"Overview OSI Layer-2"},{"location":"Network/General/OSI-Layers/OSI%20Layer-2/#overview-osi-layer-2","text":"The Data Link layer of the OSI model is responsible for interfacing with the Physical layer. Effectively, Layer 2 is responsible for putting 1\u2019s and 0\u2019s on the wire, and pulling 1\u2019s and 0\u2019s from the wire. The Network Interface Card (NIC) that you plug your Ethernet wire into handles the Layer 2 functionality. It receives signals from the wire, and transmits signals on to the wire. Your WiFi NIC works the same way, receiving and transmitting radio waves which are then interpreted as a series of 1\u2019s and 0\u2019s. Layer 2 will then group together those 1\u2019s and 0\u2019s into chunks known as Frames.","title":"Overview OSI Layer-2"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/","text":"Overview OSI Layer-3 \u2691 The network layer is responsible for packet forwading including routing trough intermediate routers. Layer 3 uses IP addresses and is responsible for packet delivery from end to end IP Packet \u2691 Version \u2691 Version number of Internet Protocol used (e.g. IPv4) IHL \u2691 Internet Header Length Length of entire IP header DSCP \u2691 Differentiated Services Code Point This is Type of Service ECN \u2691 Explicit Congestion Notification It carries information about the congestion seen in the route Total Length \u2691 Length of entire IP Packet (including IP header and IP Payload) Identification \u2691 If IP Packet is fragmented during the transmission, all the fragments contain same identificationnumber to identify original IP packet they belong to Flags \u2691 As required by the network ressources, if IP Packet is too large to handle, these \"flags\" tells if they can be fragmented or not. In this 3-bit flag, the MSB is always set to \"0\" Fragment Offset \u2691 This offset tells the exact position of the fragment in the original IP Packet Time to Live \u2691 To avoid loopoing in the network, every packet is sent with some TTL value set, which tells the network how many routers (hops) this packet can cross At each hop, its value is decremented by one and when the value reaches zero, the packet is discarded Protocol \u2691 Tells the Network layer at the destination host, to which Protocl this packet belongs to For example protocol number of ICMP is 1, TCP is 6 and UDP is 17 Header Checksum \u2691 This field is used to keep checksum value of entire header which is then used to check if the packet is received error-free Source Address \u2691 32-bit address of the Sender (or source) of the packet Destination Address \u2691 32-bit address of the Receiver (or destination) of the packet Options \u2691 This is an optional field, which is used if the value of IHL is greater than 5 These options may contain values for options such as: Security Record Route Time Stamp etc","title":"Overview OSI Layer-3"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#overview-osi-layer-3","text":"The network layer is responsible for packet forwading including routing trough intermediate routers. Layer 3 uses IP addresses and is responsible for packet delivery from end to end","title":"Overview OSI Layer-3"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#ip-packet","text":"","title":"IP Packet"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#version","text":"Version number of Internet Protocol used (e.g. IPv4)","title":"Version"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#ihl","text":"Internet Header Length Length of entire IP header","title":"IHL"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#dscp","text":"Differentiated Services Code Point This is Type of Service","title":"DSCP"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#ecn","text":"Explicit Congestion Notification It carries information about the congestion seen in the route","title":"ECN"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#total-length","text":"Length of entire IP Packet (including IP header and IP Payload)","title":"Total Length"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#identification","text":"If IP Packet is fragmented during the transmission, all the fragments contain same identificationnumber to identify original IP packet they belong to","title":"Identification"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#flags","text":"As required by the network ressources, if IP Packet is too large to handle, these \"flags\" tells if they can be fragmented or not. In this 3-bit flag, the MSB is always set to \"0\"","title":"Flags"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#fragment-offset","text":"This offset tells the exact position of the fragment in the original IP Packet","title":"Fragment Offset"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#time-to-live","text":"To avoid loopoing in the network, every packet is sent with some TTL value set, which tells the network how many routers (hops) this packet can cross At each hop, its value is decremented by one and when the value reaches zero, the packet is discarded","title":"Time to Live"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#protocol","text":"Tells the Network layer at the destination host, to which Protocl this packet belongs to For example protocol number of ICMP is 1, TCP is 6 and UDP is 17","title":"Protocol"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#header-checksum","text":"This field is used to keep checksum value of entire header which is then used to check if the packet is received error-free","title":"Header Checksum"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#source-address","text":"32-bit address of the Sender (or source) of the packet","title":"Source Address"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#destination-address","text":"32-bit address of the Receiver (or destination) of the packet","title":"Destination Address"},{"location":"Network/General/OSI-Layers/OSI%20Layer-3/#options","text":"This is an optional field, which is used if the value of IHL is greater than 5 These options may contain values for options such as: Security Record Route Time Stamp etc","title":"Options"},{"location":"Network/JunOS/Juniper%20Device%20Architecture/","text":"Juniper's architecture \u2691 Design philosophy \u2691 Junos software architecture \u2691 Junos image naming convention \u2691","title":"Juniper's architecture"},{"location":"Network/JunOS/Juniper%20Device%20Architecture/#junipers-architecture","text":"","title":"Juniper's architecture"},{"location":"Network/JunOS/Juniper%20Device%20Architecture/#design-philosophy","text":"","title":"Design philosophy"},{"location":"Network/JunOS/Juniper%20Device%20Architecture/#junos-software-architecture","text":"","title":"Junos software architecture"},{"location":"Network/JunOS/Juniper%20Device%20Architecture/#junos-image-naming-convention","text":"","title":"Junos image naming convention"},{"location":"Network/Routing/BGP/BGP%20-%20General/","text":"About BGP \u2691 BGP peering between speakers in different administrative domains (or autonomous systems in BGP parlance) is called external BGP (eBGP). BGP peering between speakers within an administrative domain (or within the same autonomous system) is called internal BGP (iBGP). BGP has different rules for eBGP peering and iBGP peering.","title":"About BGP"},{"location":"Network/Routing/BGP/BGP%20-%20General/#about-bgp","text":"BGP peering between speakers in different administrative domains (or autonomous systems in BGP parlance) is called external BGP (eBGP). BGP peering between speakers within an administrative domain (or within the same autonomous system) is called internal BGP (iBGP). BGP has different rules for eBGP peering and iBGP peering.","title":"About BGP"},{"location":"Network/Routing/BGP/BGP%20Best-Path%20Computation/","text":"A BGP router computes the best path for each advertised route, starting from itself. BGP\u2019s best-path selection is triggered when a new UPDATE message is received from one or more of its peers. BGP advertises a route only if the computation changes (adds, deletes, or updates) the best path for a given network destination. In other words, a prefix that is local to a node is preferred to one learned via BGP, and a shorter AS_PATH length route is preferred over a route with a longer AS_PATH length. If the AS_PATH lengths are equal, the paths are considered equal cost. In reality, the default BGP implementation not only requires the AS_PATH lengths to be the same to be considered equal cost, but the individual ASNs in the AS_PATH must be identical. You need to turn on a knob that relaxes this restriction and only uses the AS_PATH length in determining equal cost.","title":"BGP Best Path Computation"},{"location":"Network/Routing/BGP/BGP%20Communities/","text":"BGP also allows user-extensible grouping of routes via an attribute called communities. Communities are transitive optional attributes. Communities are used by operators to group together a set of advertised routes to apply a routing policy to. A routing policy influences the semantics of BGP Update message processing and best path computation for those routes. A single Update message can carry multiple communities. Communities are four-byte values, not arbitrary text strings. The first two bytes are always the ASN of the BGP speaker that originated the community, whereas the remaining two bytes are left up to the network operators to use as they want. Network virtualization routing information with two-byte ASNs uses extended communities, whereas the information with four-byte ASNs uses large communities.","title":"BGP Communities"},{"location":"Network/Routing/BGP/BGP%20Messages/","text":"The workhorse BGP message is Update, which carries the list of advertised routes and the list of withdrawn routes. BGP uses the term Network Layer Reachability Information (NLRI) to mean the advertised routes. Communities are encoded in the \u201cPath Attributes List\u201d section. A single BGP Update message can carry information about more than one AFI/SAFI. For example, a single BGP update message can carry updates for both IPv4 and IPv6.","title":"BGP Messages"},{"location":"Network/Routing/BGP/BGP%20Multiple%20Protocol%20Support/","text":"BGP can advertise how to reach not just IP addresses, but also other information such as MPLS labels and MAC addresses.","title":"BGP Multiple Protocol Support"},{"location":"Network/Routing/BGP/BGP%20Path%20Attributes/","text":"BGP route advertisements carry little Post-it notes. These Post-it notes are called BGP path attributes. There are different kinds of attributes, depending on their use and semantics. Attributes are encoded using the well-known Type, Length, and Value (TLV) model. The base BGP-4 RFC defines seven path attributes that every compliant implementation must support. These attributes are used in BGP\u2019s best path computation.","title":"BGP Path Attributes"},{"location":"Network/Routing/BGP/BGP%20Route%20Reflector/","text":"RR follows a hub-and-spoke model, in which all the iBGP speakers connect to a group of central RR servers. The job of the RRs is to compute the best path for a route and advertise that to each of the RR clients. However, unlike eBGP, the RR doesn\u2019t modify the next-hop network address for a route; instead, it leaves it to be whatever the value was in the advertisement that the RR received. In the case of eBGP, the next hop is always modified to be the advertising router. This is called next-hop self. In case of iBGP, the next hop associated with a route is not modified when advertised to a peer.","title":"BGP Route Reflector"},{"location":"Network/Routing/BGP/eBGP/","text":"eBGP Flying Solo \u2691 In the traditional model of deployment, BGP learns of the prefixes to advertise from another routing protocol, usually OSPF, IS-IS, or Enhanced Interior Gateway Routing Protocol (EIGRP). These are called internal routing protocols because they are used to control routing within an enterprise. However, in the data center, eBGP is the internal routing protocol. No additional one is required. BGP - General","title":"eBGP"},{"location":"Network/Routing/BGP/eBGP/#ebgp-flying-solo","text":"In the traditional model of deployment, BGP learns of the prefixes to advertise from another routing protocol, usually OSPF, IS-IS, or Enhanced Interior Gateway Routing Protocol (EIGRP). These are called internal routing protocols because they are used to control routing within an enterprise. However, in the data center, eBGP is the internal routing protocol. No additional one is required. BGP - General","title":"eBGP Flying Solo"},{"location":"Network/Routing/BGP/iBGP/","text":"BGP - General","title":"iBGP"},{"location":"Network/Routing/BGP/BGP%20EVPN/ARP%20ND%20Suppresion/","text":"ARP/ND Suppression \u2691 ARP requests and gratuitous ARP (GARP) packets are BUM packets because these packets are sent to the broadcast address. A leaf can cache a server\u2019s ARP / ND information and respond directly. This has the good effect of reducing BUM traffic in the network. This function of caching a remote host\u2019s ARP/ND information and responding to ARP/ND requests for this information is ARP/ND suppression. ARP/ND suppression uses RT-2 messages to convey the IP address associated with a MAC address in a virtual network. It is up to the implementation to decide whether it wants to send separate MAC and MAC/IP advertisements or use a single message for both. FRR uses a single message update model when ARP/ND suppression is enabled. The kernel does not attempt to run ARP refresh for such entries. The kernel also does not age out entries that have been marked as learned via a control protocol. The protocol is responsible for removing these entries when the remote entries, advertisements are withdrawn. FRR also removes them on graceful shutdown or on recovery from a crash.","title":"ARP/ND Suppression"},{"location":"Network/Routing/BGP/BGP%20EVPN/ARP%20ND%20Suppresion/#arpnd-suppression","text":"ARP requests and gratuitous ARP (GARP) packets are BUM packets because these packets are sent to the broadcast address. A leaf can cache a server\u2019s ARP / ND information and respond directly. This has the good effect of reducing BUM traffic in the network. This function of caching a remote host\u2019s ARP/ND information and responding to ARP/ND requests for this information is ARP/ND suppression. ARP/ND suppression uses RT-2 messages to convey the IP address associated with a MAC address in a virtual network. It is up to the implementation to decide whether it wants to send separate MAC and MAC/IP advertisements or use a single message for both. FRR uses a single message update model when ARP/ND suppression is enabled. The kernel does not attempt to run ARP refresh for such entries. The kernel also does not age out entries that have been marked as learned via a control protocol. The protocol is responsible for removing these entries when the remote entries, advertisements are withdrawn. FRR also removes them on graceful shutdown or on recovery from a crash.","title":"ARP/ND Suppression"},{"location":"Network/Routing/BGP/BGP%20EVPN/BGP%20EVPN%20-%20General/","text":"BGP EVPN \u2691 What is BGP EVPN? \u2691 EVPN is a solution that provides the control plane for network virtualization. In the simplest of terms, EVPN is a technology that connects L2 network segments separated by an L3 network. EVPN accomplishes this by building the L2 network as a virtual Layer 2 network overlay over the Layer 3 network. It uses BGP as its control protocol, and in the data center it uses VXLAN for packet encapsulation. It relies on multi-protocol BGP (MP-BGP) to exchange information and is based on BGP-MPLS IP VPNs ( RFC 4364 ). The MP-BGP extensions can carry reachability information (NLRI) for multiple protocols (IPv4, IPv6, L3VPN and in our case EVPN). EVPN is a special family to advertise MAC addresses and the remote equipments they are attached to. It enables not only bridging between end systems in the same layer 2 segment but also routing between different segments (subnets). There is also inherent support for multi-tenancy. EVPN is often referred to as the means of implementing controller-less VXLAN . There are two kinds of reachability information a VTEP sends through BGP EVPN: 1. the VNIs they have interest in (type 3 routes), and 2. for each VNI, the local MAC addresses (type 2 routes). BGP Constructs to Support Virtual Network Routes \u2691 BGP added a few constructs to support advertising virtual network routes. These first arose in the context of MPLS L3VPNs in service provider networks. The first issue is what AFI/SAFI to use. EVPN uses the AFI/SAFI of l2vpn/evpn. This is because EVPN is considered to be a kind of an L2 VPN. Next, BGP must handle the model allowing addresses to be duplicated across virtual networks. Every BGP implementation I know of maintains two kinds of routing tables: a global one and one per virtual network. BGP runs the best-path algorithm on the global table to pick a single path to advertise for each prefix to its peers. Because the RD is unique to each originator, all copies of a route will be advertised to a neighbor. To install routes into a virtual network\u2019s routing table, BGP first uses the import RT clause to select specific candidate routes from the global table to import into this virtual network. Then, it runs the best-path algorithm again on the imported candidate routes, but this time within the context of the virtual network\u2019s routing table. If the same address is advertised with multiple RTs, the best-path algorithm selects the best one. Multiple RTs can be imported into a single virtual network routing table. Route Distinguisher \u2691 Format of RD for use with EVPN If you\u2019re wondering how the Virtual Network Instance (VNI) is three bytes long but can be encoded in a two-byte space in the RD, this is not an issue, because it is assumed that no VTEP will, in practice, host more than 64,000 VNIs. It is the combination of the router\u2019s IPv4 loopback address plus the VNI that makes the RD unique across the network. Thus, the value of the VNI-specific part of the RD is a device-local encoding of the VNI, not necessarily the absolute value of the VNI. Because the router\u2019s loopback IP address is part of the RD, two nodes with the same virtual network will end up having different RDs. This solves the problem of distinguishing sources with the same IP address. The RD is encoded as part of the NLRI in the MP_REACH_NLRI and MP_UNREACH_NLRI attributes. Route Target \u2691 RT is an additional path attribute added to virtual network NLRIs. A BGP speaker advertising virtual networks and their addresses uses a specific RT called the export RT. A BGP speaker receiving and using the advertisement uses this RT to decide which local virtual network to add the routes to. This is called the import RT. Format of RT for use with EVPN-VXLAN: ASN The two-byte ASN of the BGP speaker advertising the address. A A bit indicating whether the RT is autoderived or manually configured. Type A three-bit field indicating the encapsulation used in EVPN. For VXLAN, it is 1, and for VLAN, it is 0. Domain-ID (D-ID) Four bits that are typically zero. In certain cases, if there is an overlap in the VXLAN numbering space, this field is used to qualify the administrative domain to which the VNI belongs. Service ID Three bytes containing the virtual network identifier. For VXLAN, it is the 3-byte VNI; for VLAN it is 12 bits (the lower 12 bits of the 3-byte field). Route Types \u2691 BGP - General","title":"BGP EVPN"},{"location":"Network/Routing/BGP/BGP%20EVPN/BGP%20EVPN%20-%20General/#bgp-evpn","text":"","title":"BGP EVPN"},{"location":"Network/Routing/BGP/BGP%20EVPN/BGP%20EVPN%20-%20General/#what-is-bgp-evpn","text":"EVPN is a solution that provides the control plane for network virtualization. In the simplest of terms, EVPN is a technology that connects L2 network segments separated by an L3 network. EVPN accomplishes this by building the L2 network as a virtual Layer 2 network overlay over the Layer 3 network. It uses BGP as its control protocol, and in the data center it uses VXLAN for packet encapsulation. It relies on multi-protocol BGP (MP-BGP) to exchange information and is based on BGP-MPLS IP VPNs ( RFC 4364 ). The MP-BGP extensions can carry reachability information (NLRI) for multiple protocols (IPv4, IPv6, L3VPN and in our case EVPN). EVPN is a special family to advertise MAC addresses and the remote equipments they are attached to. It enables not only bridging between end systems in the same layer 2 segment but also routing between different segments (subnets). There is also inherent support for multi-tenancy. EVPN is often referred to as the means of implementing controller-less VXLAN . There are two kinds of reachability information a VTEP sends through BGP EVPN: 1. the VNIs they have interest in (type 3 routes), and 2. for each VNI, the local MAC addresses (type 2 routes).","title":"What is BGP EVPN?"},{"location":"Network/Routing/BGP/BGP%20EVPN/BGP%20EVPN%20-%20General/#bgp-constructs-to-support-virtual-network-routes","text":"BGP added a few constructs to support advertising virtual network routes. These first arose in the context of MPLS L3VPNs in service provider networks. The first issue is what AFI/SAFI to use. EVPN uses the AFI/SAFI of l2vpn/evpn. This is because EVPN is considered to be a kind of an L2 VPN. Next, BGP must handle the model allowing addresses to be duplicated across virtual networks. Every BGP implementation I know of maintains two kinds of routing tables: a global one and one per virtual network. BGP runs the best-path algorithm on the global table to pick a single path to advertise for each prefix to its peers. Because the RD is unique to each originator, all copies of a route will be advertised to a neighbor. To install routes into a virtual network\u2019s routing table, BGP first uses the import RT clause to select specific candidate routes from the global table to import into this virtual network. Then, it runs the best-path algorithm again on the imported candidate routes, but this time within the context of the virtual network\u2019s routing table. If the same address is advertised with multiple RTs, the best-path algorithm selects the best one. Multiple RTs can be imported into a single virtual network routing table.","title":"BGP Constructs to Support Virtual Network Routes"},{"location":"Network/Routing/BGP/BGP%20EVPN/BGP%20EVPN%20-%20General/#route-distinguisher","text":"Format of RD for use with EVPN If you\u2019re wondering how the Virtual Network Instance (VNI) is three bytes long but can be encoded in a two-byte space in the RD, this is not an issue, because it is assumed that no VTEP will, in practice, host more than 64,000 VNIs. It is the combination of the router\u2019s IPv4 loopback address plus the VNI that makes the RD unique across the network. Thus, the value of the VNI-specific part of the RD is a device-local encoding of the VNI, not necessarily the absolute value of the VNI. Because the router\u2019s loopback IP address is part of the RD, two nodes with the same virtual network will end up having different RDs. This solves the problem of distinguishing sources with the same IP address. The RD is encoded as part of the NLRI in the MP_REACH_NLRI and MP_UNREACH_NLRI attributes.","title":"Route Distinguisher"},{"location":"Network/Routing/BGP/BGP%20EVPN/BGP%20EVPN%20-%20General/#route-target","text":"RT is an additional path attribute added to virtual network NLRIs. A BGP speaker advertising virtual networks and their addresses uses a specific RT called the export RT. A BGP speaker receiving and using the advertisement uses this RT to decide which local virtual network to add the routes to. This is called the import RT. Format of RT for use with EVPN-VXLAN: ASN The two-byte ASN of the BGP speaker advertising the address. A A bit indicating whether the RT is autoderived or manually configured. Type A three-bit field indicating the encapsulation used in EVPN. For VXLAN, it is 1, and for VLAN, it is 0. Domain-ID (D-ID) Four bits that are typically zero. In certain cases, if there is an overlap in the VXLAN numbering space, this field is used to qualify the administrative domain to which the VNI belongs. Service ID Three bytes containing the virtual network identifier. For VXLAN, it is the 3-byte VNI; for VLAN it is 12 bits (the lower 12 bits of the 3-byte field).","title":"Route Target"},{"location":"Network/Routing/BGP/BGP%20EVPN/BGP%20EVPN%20-%20General/#route-types","text":"BGP - General","title":"Route Types"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Route%20Types/","text":"EVPN Route Types \u2691 Route Type What it carries Primary use RT-1 Ethernet Segment Auto Discover Supports multihomed endpoints in the data center, used instead of MLAG RT-2 MAC, VNI, IP Advertises reachability to a specific MAC address in a virtual network, and its IP address RT-3 VNI/VTEP Association Advertises a VTEP's interest in virtual networks RT-4 Designated Forwarder Ensures that only a single VTEP forwards multidestination frames to multihomed endpoints RT-5 IP prefix, VRF Advertises IP prefixes, such as summarized routes, and the VRF associated with the prefix RT-6 Multicast group membership Contains information about which multicast groups an endpoint attached to a VTEP interested in it RT-2 \u2691 When ARP/ND suppression or routing is disabled, only the RD, MAC address, and MPLS Label1 fields in the message are used. The MAC address length field is always set to six, the MAC address field carries the MAC address, and the MPLS Label 1 field carries the L2 VNI associated with the MAC address. EVPN RT-2 message format When ARP/ND or routing is enabled, the IP address associated with the {VNI, MAC} is also advertised. Implementations might choose to send two separate RT-2 advertisements, one for just the MAC and the other for the MAC/IP, or just a single MAC/IP advertisement. When only asymmetric routing is used, MPLS Label1 carries the L2 VNI associated with the MAC/IP binding, and MPLS Label2 is not used. When symmetric routing is used, MPLS Label2 field carries the L3 VNI.","title":"EVPN Route Types"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Route%20Types/#evpn-route-types","text":"Route Type What it carries Primary use RT-1 Ethernet Segment Auto Discover Supports multihomed endpoints in the data center, used instead of MLAG RT-2 MAC, VNI, IP Advertises reachability to a specific MAC address in a virtual network, and its IP address RT-3 VNI/VTEP Association Advertises a VTEP's interest in virtual networks RT-4 Designated Forwarder Ensures that only a single VTEP forwards multidestination frames to multihomed endpoints RT-5 IP prefix, VRF Advertises IP prefixes, such as summarized routes, and the VRF associated with the prefix RT-6 Multicast group membership Contains information about which multicast groups an endpoint attached to a VTEP interested in it","title":"EVPN Route Types"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Route%20Types/#rt-2","text":"When ARP/ND suppression or routing is disabled, only the RD, MAC address, and MPLS Label1 fields in the message are used. The MAC address length field is always set to six, the MAC address field carries the MAC address, and the MPLS Label 1 field carries the L2 VNI associated with the MAC address. EVPN RT-2 message format When ARP/ND or routing is enabled, the IP address associated with the {VNI, MAC} is also advertised. Implementations might choose to send two separate RT-2 advertisements, one for just the MAC and the other for the MAC/IP, or just a single MAC/IP advertisement. When only asymmetric routing is used, MPLS Label1 carries the L2 VNI associated with the MAC/IP binding, and MPLS Label2 is not used. When symmetric routing is used, MPLS Label2 field carries the L3 VNI.","title":"RT-2"},{"location":"Network/Routing/BGP/BGP%20EVPN/Route%20Advertisements/","text":"EVPN Route Advertisements \u2691 An EVPN RT-2 advertisement contains the IP address associated with a {MAC, VNI} tuple. This information is used to populate the routing table. But there are cases for which we need a summarized route or a route to be advertised that has been learned as an IP route. Consider where the routing table needs to be populated with the default route that leads to the outside world. Typically, the exit leaves advertise this route. A new route type, RT-5, was introduced to advertise IP routes. IP routes are not advertised automatically; they must be configured. IP routes are always advertised with an L3 VNI. Every device maps the L3 VNI to a local VRF before populating the routing table. There are three additional pieces of information required for symmetric routing: the VNI to use between the ingress and egress VTEPs, the next-hop IP address (which is the egress VTEP\u2019s IP address), and the router MAC address of the egress VTEP. These need to be conveyed in some BGP UPDATE message. The egress VTEP\u2019s IP address is always carried in the NEXTHOP attribute of the BGP advertisement. The RT-2 mes\u2010 sage has provisions allowing it to carry the other two pieces of information. The route also needs to carry the egress VTEP\u2019s MAC address, because this address is used as the destination MAC address on the inner packet. This MAC address is carried as a new BGP Extended Community in the advertisement. This new extended community is called the Router MAC Extended Community. The Use of VRFs \u2691 In EVPN, routing is assumed to occur within the context of a VRF. The underlay routing table is assumed to be in the default or global routing table, whereas the overlay routing table is assumed to be in a VRF-specific routing table. RT-5 advertisements always occur in the context of a VRF: the L3 VNI signaled in the advertisement. Thus, to preserve a uniform routing model, I strongly recommend always using VRFs with EVPN routing. EVPN Route Types","title":"EVPN Route Advertisements"},{"location":"Network/Routing/BGP/BGP%20EVPN/Route%20Advertisements/#evpn-route-advertisements","text":"An EVPN RT-2 advertisement contains the IP address associated with a {MAC, VNI} tuple. This information is used to populate the routing table. But there are cases for which we need a summarized route or a route to be advertised that has been learned as an IP route. Consider where the routing table needs to be populated with the default route that leads to the outside world. Typically, the exit leaves advertise this route. A new route type, RT-5, was introduced to advertise IP routes. IP routes are not advertised automatically; they must be configured. IP routes are always advertised with an L3 VNI. Every device maps the L3 VNI to a local VRF before populating the routing table. There are three additional pieces of information required for symmetric routing: the VNI to use between the ingress and egress VTEPs, the next-hop IP address (which is the egress VTEP\u2019s IP address), and the router MAC address of the egress VTEP. These need to be conveyed in some BGP UPDATE message. The egress VTEP\u2019s IP address is always carried in the NEXTHOP attribute of the BGP advertisement. The RT-2 mes\u2010 sage has provisions allowing it to carry the other two pieces of information. The route also needs to carry the egress VTEP\u2019s MAC address, because this address is used as the destination MAC address on the inner packet. This MAC address is carried as a new BGP Extended Community in the advertisement. This new extended community is called the Router MAC Extended Community.","title":"EVPN Route Advertisements"},{"location":"Network/Routing/BGP/BGP%20EVPN/Route%20Advertisements/#the-use-of-vrfs","text":"In EVPN, routing is assumed to occur within the context of a VRF. The underlay routing table is assumed to be in the default or global routing table, whereas the overlay routing table is assumed to be in a VRF-specific routing table. RT-5 advertisements always occur in the context of a VRF: the L3 VNI signaled in the advertisement. Thus, to preserve a uniform routing model, I strongly recommend always using VRFs with EVPN routing. EVPN Route Types","title":"The Use of VRFs"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/","text":"How EVPN replaces the 802.Q flood-and-learn \u2691 The primary difference is that EVPN uses BGP to distribute reachability to MAC addresses and IP routes along with the associated virtual network. Also, STP is not used. The leaves are the VTEPs. To function as a VTEP, they need an IP address to source and receive packets. Typically, a single IP address is used across all VNIs. EVPN has also been enabled on all the leaves. 802.1Q bridging is enabled only on the ports between a leaf and the servers locally attached to it, as in a Clos network. The spines are only part of the underlay. Assume that the red VLAN (represented by the thick line) is mapped to the red VNI, and the blue VLAN (represented by the thinner line) to the blue VNI. Different leaves can associate a subnet with different VLAN IDs as long as all those different VLAN IDs map to the same global VNI. All information exchanged in EVPN is about the global VNI, not the local VLAN instantiation of it. Thus, the subnet is also associated with the global VNI because it spans multiple routers. Every leaf has a second IP address, the VTEP IP address, associated with it in the 10.0.127.0/24 subnet; all VXLAN-encapsulated packets will have the source and destination IP address from this subnet. The network administrator must also ensure that this VTEP IP address is advertised via BGP; otherwise, the other VTEPs will not know how to reach this address. Each leaf learns about the virtual networks every other leaf is interested in via RT-3 routes. So leaf01 knows that leaf02 and leaf04 are interested in the red VNI, and leaf03 and leaf04 are interested in the blue VNI. Similarly, other leaves learn this information from the BGP UPDATEs. EVPN Bridging with Ingress Replication \u2691 Let\u2019s have server101 send a packet to server104. Because server101 and server104 belong to the same subnet, server101 sends an ARP request packet asking for server104\u2019s MAC address. This goes in the form of a Ethernet broadcast packet with the destination MAC101 of FF:FF:FF:FF:FF:FF and a source MAC address. The packet sent from server101 to leaf01 is no different in this case from traditional bridging. leaf01 receives this packet and, just as in traditional bridging, learns that MAC101 is reachable via the port attached to server101. leaf01 understands that the packet is a broadcast packet and so needs to be sent to all the recipients of the red VNI. leaf01 uses head-end replication to flood the packet to all the interested leaves\u2014in this case leaf02 and leaf04. Leaf01 VXLAN encapsulates the packet and sends one copy to spine01 (destined to leaf02) and one to spine02 (destined to leaf03). The packet to leaf02 has the destination IP address of leaf02\u2019s VTEP\u2014for instance 10.0.127.12\u2014and the source IP address of leaf01, 10.0.127.11. Similarly, the packet to leaf04 has the destination IP address of 10.0.127.14 and the source IP address of 10.0.127.11. When spine01 receives the packet, it does a routing lookup of the IP in the VXLAN header, which is that of leaf02. It then routes the packet out the port to leaf02. spine02 does the same for the packet destined to leaf04. When these VXLAN-encapsulated packets reach leaf02 and leaf04, they each know that they are the egress VTEP because the destination IP address in the packet is their IP address and the UDP destination port says that this is a VXLAN packet. They decapsulate the packet and use local 802.1Q bridging to determine the locally attached ports to which to send the packet out Neither leaf02 nor leaf04 learn anything about MAC101 from this flooded packet. However, leaf01 has a new local entry in its MAC forwarding table. So leaf01 advertises the reachability to MAC101 in the red virtual network via a BGP UPDATE message. Specifically, it uses an EVPN RT-2 message, which carries the {VNI, MAC} advertisement. The message says that MAC101 in the red virtual network is reachable via the VTEP leaf01. leaf01 delivers this information to its BGP peers, spine01 and spine02. spine01 and spine02 in turn deliver this message to their peers, which are leaves leaf02, leaf03, and leaf04. The leaves receive multiple copies of the updates, one from each of the spines. These leaves now populate their MAC forwarding tables with information about MAC101. They note that MAC101 is remote and reachable via the leaf01\u2019s VTEP IP address, 10.0.127.11. leaf03, which has no red VNI, simply stores this message (or can discard it). If server104\u2019s ARP reply to server101 arrives before the MAC table update on leaf04, the return packet can be flooded just like the broadcast packet because leaf04 doesn\u2019t know about MAC101 yet. If the ARP reply arrives after leaf04 has updated its MAC table based on the BGP UPDATE from leaf01, the reply can be sent directly only to leaf01. Leaf04 also learns that MAC104 in the red VNI is attached to the local port pointing out to server104. leaf04 sends a BGP UPDATE message with an EVPN RT-2 type indicating that MAC104 in the red VNI is reachable via leaf04. This message is delivered to both spine01 and spine02. They deliver this BGP UPDATE to all the other leaves. At the end of the BGP processing, leaf01, leaf02, and leaf04 know that MAC101 in the red VNI is reachable via VTEP leaf01 and that MAC104 in the red VNI is reachable via leaf04. Primary differences between EVPN bridging from traditional 802.1Q bridging \u2691 Inserting the remote MAC address into the MAC table is done via BGP UPDATEs in EVPN, instead of learning from the data packet itself in 802.1Q The path of the reply from server104 to server101 can take a different path compared to the packet from server101 to server104 in EVPN, whereas they're the same in 802.1Q bridging. Common between EVPN bridging and 802.1Q bridging \u2691 Locally attached MACs are populated in the MAC table via standard 802.1Q learning Flooded packets are delivered to all end stations in the virtual network Each {virtual network, MAC address} tuple is associated with a single egress port Handling MAC Moves \u2691 Let server101 host a VM with a MAC address of MACVM 101. After it first speaks, using the model of EVPN bridging, all leaves learn that MACVM101 is being associated with VTEP leaf01. Now consider what happens if the VM now migrates to server102. When it first speaks after the move, leaf02 learns that MACVM101 is locally attached to itself. It also has an entry that states that MACVM101 is associated with leaf01 populated via BGP. Because locally attached entries take precedence over entries learned via BGP, leaf02 switches its MAC table to have MACVM101 point out the port to server102. It then sends out a BGP EVPN RT-2 UPDATE message indicating that others should switch their association for MACVM101 to leaf02. leaf04 does so without a problem. But leaf01 thinks that MAC address is locally attached to itself. Because locally attached entries take precedence over entries learned via BGP, leaf01 will not switch its association for MACVM101 to leaf02, but continues to think it is locally attached. This is wrong. To fix this issue, EVPN defines a new BGP extended community called MAC Mobility. BGP Communities The first basic rule about using this extended community is that it must be used for advertising a MAC address that is locally learned, if the MAC address is already associated with a remote VTEP. The sequence number indicates the number of times this MAC address has moved. For instance, the first time this attribute is attached to an RT-2 advertisement of a MAC address, the sequence number is bumped to 1. The second basic rule is that if you receive an advertisement for a MAC address in a virtual network with this extended community, you must accept this advertisement as the best path either if you don\u2019t hold an entry with this extended community or if the sequence number in the new advertisement is higher than the one currently in your database. In case multiple updates are received with the same sequence number but from different VTEPs, the one with the lower VTEP IP address wins. Static MAC addresses are MAC addresses that are not allowed to move. When advertising such MAC addresses, the route must be tagged with the MAC Mobility extended community with the \u201cS\u201d bit in the community set. When any VTEP receives a MAC advertisement with such a tag, it must ignore any locally detected changes in that MAC address in the associated virtual network. Incorrect MAC moves \u2691 Sometimes, messages indicating that a MAC address moved are incorrect. One reason is lax security in L2 networks, making it possible to spoof a MAC address and make it move from a safe host to a compromised host. Another reason for spurious moves is that a problem in a connected 802.1Q network can cause the STP to continuously update its tree. When the tree is updated, a MAC address might appear in a different location in the tree, making it look like the MAC address moved. To handle all of these cases, if a VTEP detects that a MAC address is updating too frequently, it can stop sending or handling further updates to that MAC address. It must also notify the administrator that this is happening. There is no clearly defined way to get out of this situation. FRR\u2019s EVPN implementation supports MAC Mobility as defined by the standard. If it detects that a MAC address has moved too many times within a specified time period, it ignores MAC address updates associated with the MAC address for some time, before restarting the MAC Mobility timer. The number of moves and the time periods can all be specified. Support for Dual-Attached Hosts \u2691 VXLAN Model for Dual-Attached Hosts \u2691 Most packet-switching silicon implementations as of this writing assume that a MAC address is behind a single VTEP. There are two possibilities: each VTEP has its own IP address or both VTEPs share a common IP address. The shared VTEP IP address is the most common deployment. The main reason for this is that the common implementation of a MAC forwarding table supports only a single port of exit. leaf01 and leaf02 will both transmit packets for all dual-attached hosts with a source VTEP IP address that is common to them both. Most implementations verify that the switches have the same common IP address configured via a protocol such as the Multichassis Link Aggregation (MLAG) Switch Peering Options \u2691 Before we proceed to look at the other problems and how they are handled, we must examine the model adopted by the pair of switches to which the dual-attached hosts are connected. There are essentially two answers: MLAG and EVPN. MLAG \u2691 The standard LACP does not support creating a bond when the links are split at one end across multiple devices. Therefore, every networking vendor has their own proprietary solution to provide that illusion. The generic name for this solution is MLAG. EVPN support for multihoming \u2691 EVPN supports dual-attached devices natively. It calls them multihomed nodes. Primarily, EVPN uses RT-1 and RT-4 message types to handle multihomed nodes. RT-1 tells the network which switches are attached to which common devices or Ethernet segments. An Ethernet segment in a data center is defined as either the bridged network to which a VTEP is connected or a bonded link. EVPN Route Types When connected to a bond, the RT-1 advertisement carries the LACP identifier of the remote node (i.e., the host in our case) as the Ethernet segment ID (ESI). When other VTEPs receive the BGP updates of this RT-1 advertisement, they can determine which of their peers are attached to the same host. RT-4 elects one of the peers as the designated forwarder for multidestination frames. The RT-4 advertisement carries the mapping of the Ethernet segment to the router servicing the segment. From all the advertisements received for an Ethernet segment, each VTEP selects the segment with the lowest VTEP IP address as the designated forwarder for a virtual network. In this case, a common VTEP IP address is not required across the two peers. Let\u2019s break this down using our sample topology. First, the standard allows leaf01 to be the designated forwarder for one set of nodes\u2014say server101 and server201\u2014and leaf02 to be the designated forwarder for another set of nodes\u2014say server102. In Pasted image 20210725123337.png , each host carries only a single VLAN. But if the hosts supported multiple VLANs, the standard further allows leaf01 to be the designated forwarder for a node \u2014say server101\u2014for one set of VLANs, and leaf02 as the designated forwarder for that node for a different set of VLANs. Handling Link failures \u2691 MLAG \u2691 In the case of MLAG, using the peer link to reach the host via the other switch is the most common implementation. In our example, both leaf01 and leaf02 advertise reachability to server102 via a common VTEP IP. The underlay multipaths traffic addressed to the common VTEP IP between leaf01 and leaf02. When leaf01 loses its connectivity to server102, it withdraws its advertisement of server102. However, because leaf02\u2019s advertisement is still valid, leaf03 and leaf04 see that MAC102 is still reachable via the common VTEP IP. So, a packet to server102 can still end up at leaf01, even though the link between them is down and leaf01 cannot deliver the packet directly. In such cases, leaf01 decapsulates the packet and uses the peer link to send the packet unencapsulated to leaf02, which then delivers the packet to server102. EVPN Multihoming \u2691 In EVPN multihoming implementations, the switch that lost the connectivity to the host will also withdraw reachability to the ESI identified by the LACP of the host. This is done for both RT-1 and RT-4 routes. The other switch eventually receives these withdrawals. On receiving the RT-4 withdrawal, the remaining switch appoints itself the designated forwarder for server102. Receiving the RT-1 withdrawal tells the switch that the host is singly attached to it. The switch cannot attempt to forward the packet to its peer when it loses connectivity to the host. In our example, when leaf02 receives the withdrawal originated by leaf01, it knows that if it loses the link to server102, it cannot forward a packet to leaf01. However, reencapsulating a VXLAN packet without routing violates the split-horizon check. Avoiding Duplicate Multidestination Frames \u2691 When the common VTEP IP model and ingress replication are used, only one of the pair of switches gets a packet. This is because the other VTEPs represent the pair with a single common VTEP IP address, and one is chosen at random to get an anycast packet. However, in the model without a shared common VTEP IP address, both switches will get a copy of multidestination frames (BUM packets, for example). To ensure that only one of the pair sends a packet to the end station, the two nodes use the RT-4 message to pick only one of them to deliver a multidestination frame in a virtual network. However, control protocol updates take time, and during the process of electing a designated forwarder or during transitions, the host can either receive no multidestination frames or receive duplicates.","title":"How EVPN replaces the 802.Q flood-and-learn"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#how-evpn-replaces-the-802q-flood-and-learn","text":"The primary difference is that EVPN uses BGP to distribute reachability to MAC addresses and IP routes along with the associated virtual network. Also, STP is not used. The leaves are the VTEPs. To function as a VTEP, they need an IP address to source and receive packets. Typically, a single IP address is used across all VNIs. EVPN has also been enabled on all the leaves. 802.1Q bridging is enabled only on the ports between a leaf and the servers locally attached to it, as in a Clos network. The spines are only part of the underlay. Assume that the red VLAN (represented by the thick line) is mapped to the red VNI, and the blue VLAN (represented by the thinner line) to the blue VNI. Different leaves can associate a subnet with different VLAN IDs as long as all those different VLAN IDs map to the same global VNI. All information exchanged in EVPN is about the global VNI, not the local VLAN instantiation of it. Thus, the subnet is also associated with the global VNI because it spans multiple routers. Every leaf has a second IP address, the VTEP IP address, associated with it in the 10.0.127.0/24 subnet; all VXLAN-encapsulated packets will have the source and destination IP address from this subnet. The network administrator must also ensure that this VTEP IP address is advertised via BGP; otherwise, the other VTEPs will not know how to reach this address. Each leaf learns about the virtual networks every other leaf is interested in via RT-3 routes. So leaf01 knows that leaf02 and leaf04 are interested in the red VNI, and leaf03 and leaf04 are interested in the blue VNI. Similarly, other leaves learn this information from the BGP UPDATEs.","title":"How EVPN replaces the 802.Q flood-and-learn"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#evpn-bridging-with-ingress-replication","text":"Let\u2019s have server101 send a packet to server104. Because server101 and server104 belong to the same subnet, server101 sends an ARP request packet asking for server104\u2019s MAC address. This goes in the form of a Ethernet broadcast packet with the destination MAC101 of FF:FF:FF:FF:FF:FF and a source MAC address. The packet sent from server101 to leaf01 is no different in this case from traditional bridging. leaf01 receives this packet and, just as in traditional bridging, learns that MAC101 is reachable via the port attached to server101. leaf01 understands that the packet is a broadcast packet and so needs to be sent to all the recipients of the red VNI. leaf01 uses head-end replication to flood the packet to all the interested leaves\u2014in this case leaf02 and leaf04. Leaf01 VXLAN encapsulates the packet and sends one copy to spine01 (destined to leaf02) and one to spine02 (destined to leaf03). The packet to leaf02 has the destination IP address of leaf02\u2019s VTEP\u2014for instance 10.0.127.12\u2014and the source IP address of leaf01, 10.0.127.11. Similarly, the packet to leaf04 has the destination IP address of 10.0.127.14 and the source IP address of 10.0.127.11. When spine01 receives the packet, it does a routing lookup of the IP in the VXLAN header, which is that of leaf02. It then routes the packet out the port to leaf02. spine02 does the same for the packet destined to leaf04. When these VXLAN-encapsulated packets reach leaf02 and leaf04, they each know that they are the egress VTEP because the destination IP address in the packet is their IP address and the UDP destination port says that this is a VXLAN packet. They decapsulate the packet and use local 802.1Q bridging to determine the locally attached ports to which to send the packet out Neither leaf02 nor leaf04 learn anything about MAC101 from this flooded packet. However, leaf01 has a new local entry in its MAC forwarding table. So leaf01 advertises the reachability to MAC101 in the red virtual network via a BGP UPDATE message. Specifically, it uses an EVPN RT-2 message, which carries the {VNI, MAC} advertisement. The message says that MAC101 in the red virtual network is reachable via the VTEP leaf01. leaf01 delivers this information to its BGP peers, spine01 and spine02. spine01 and spine02 in turn deliver this message to their peers, which are leaves leaf02, leaf03, and leaf04. The leaves receive multiple copies of the updates, one from each of the spines. These leaves now populate their MAC forwarding tables with information about MAC101. They note that MAC101 is remote and reachable via the leaf01\u2019s VTEP IP address, 10.0.127.11. leaf03, which has no red VNI, simply stores this message (or can discard it). If server104\u2019s ARP reply to server101 arrives before the MAC table update on leaf04, the return packet can be flooded just like the broadcast packet because leaf04 doesn\u2019t know about MAC101 yet. If the ARP reply arrives after leaf04 has updated its MAC table based on the BGP UPDATE from leaf01, the reply can be sent directly only to leaf01. Leaf04 also learns that MAC104 in the red VNI is attached to the local port pointing out to server104. leaf04 sends a BGP UPDATE message with an EVPN RT-2 type indicating that MAC104 in the red VNI is reachable via leaf04. This message is delivered to both spine01 and spine02. They deliver this BGP UPDATE to all the other leaves. At the end of the BGP processing, leaf01, leaf02, and leaf04 know that MAC101 in the red VNI is reachable via VTEP leaf01 and that MAC104 in the red VNI is reachable via leaf04.","title":"EVPN Bridging with Ingress Replication"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#primary-differences-between-evpn-bridging-from-traditional-8021q-bridging","text":"Inserting the remote MAC address into the MAC table is done via BGP UPDATEs in EVPN, instead of learning from the data packet itself in 802.1Q The path of the reply from server104 to server101 can take a different path compared to the packet from server101 to server104 in EVPN, whereas they're the same in 802.1Q bridging.","title":"Primary differences between EVPN bridging from traditional 802.1Q bridging"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#common-between-evpn-bridging-and-8021q-bridging","text":"Locally attached MACs are populated in the MAC table via standard 802.1Q learning Flooded packets are delivered to all end stations in the virtual network Each {virtual network, MAC address} tuple is associated with a single egress port","title":"Common between EVPN bridging and 802.1Q bridging"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#handling-mac-moves","text":"Let server101 host a VM with a MAC address of MACVM 101. After it first speaks, using the model of EVPN bridging, all leaves learn that MACVM101 is being associated with VTEP leaf01. Now consider what happens if the VM now migrates to server102. When it first speaks after the move, leaf02 learns that MACVM101 is locally attached to itself. It also has an entry that states that MACVM101 is associated with leaf01 populated via BGP. Because locally attached entries take precedence over entries learned via BGP, leaf02 switches its MAC table to have MACVM101 point out the port to server102. It then sends out a BGP EVPN RT-2 UPDATE message indicating that others should switch their association for MACVM101 to leaf02. leaf04 does so without a problem. But leaf01 thinks that MAC address is locally attached to itself. Because locally attached entries take precedence over entries learned via BGP, leaf01 will not switch its association for MACVM101 to leaf02, but continues to think it is locally attached. This is wrong. To fix this issue, EVPN defines a new BGP extended community called MAC Mobility. BGP Communities The first basic rule about using this extended community is that it must be used for advertising a MAC address that is locally learned, if the MAC address is already associated with a remote VTEP. The sequence number indicates the number of times this MAC address has moved. For instance, the first time this attribute is attached to an RT-2 advertisement of a MAC address, the sequence number is bumped to 1. The second basic rule is that if you receive an advertisement for a MAC address in a virtual network with this extended community, you must accept this advertisement as the best path either if you don\u2019t hold an entry with this extended community or if the sequence number in the new advertisement is higher than the one currently in your database. In case multiple updates are received with the same sequence number but from different VTEPs, the one with the lower VTEP IP address wins. Static MAC addresses are MAC addresses that are not allowed to move. When advertising such MAC addresses, the route must be tagged with the MAC Mobility extended community with the \u201cS\u201d bit in the community set. When any VTEP receives a MAC advertisement with such a tag, it must ignore any locally detected changes in that MAC address in the associated virtual network.","title":"Handling MAC Moves"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#incorrect-mac-moves","text":"Sometimes, messages indicating that a MAC address moved are incorrect. One reason is lax security in L2 networks, making it possible to spoof a MAC address and make it move from a safe host to a compromised host. Another reason for spurious moves is that a problem in a connected 802.1Q network can cause the STP to continuously update its tree. When the tree is updated, a MAC address might appear in a different location in the tree, making it look like the MAC address moved. To handle all of these cases, if a VTEP detects that a MAC address is updating too frequently, it can stop sending or handling further updates to that MAC address. It must also notify the administrator that this is happening. There is no clearly defined way to get out of this situation. FRR\u2019s EVPN implementation supports MAC Mobility as defined by the standard. If it detects that a MAC address has moved too many times within a specified time period, it ignores MAC address updates associated with the MAC address for some time, before restarting the MAC Mobility timer. The number of moves and the time periods can all be specified.","title":"Incorrect MAC moves"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#support-for-dual-attached-hosts","text":"","title":"Support for Dual-Attached Hosts"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#vxlan-model-for-dual-attached-hosts","text":"Most packet-switching silicon implementations as of this writing assume that a MAC address is behind a single VTEP. There are two possibilities: each VTEP has its own IP address or both VTEPs share a common IP address. The shared VTEP IP address is the most common deployment. The main reason for this is that the common implementation of a MAC forwarding table supports only a single port of exit. leaf01 and leaf02 will both transmit packets for all dual-attached hosts with a source VTEP IP address that is common to them both. Most implementations verify that the switches have the same common IP address configured via a protocol such as the Multichassis Link Aggregation (MLAG)","title":"VXLAN Model for Dual-Attached Hosts"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#switch-peering-options","text":"Before we proceed to look at the other problems and how they are handled, we must examine the model adopted by the pair of switches to which the dual-attached hosts are connected. There are essentially two answers: MLAG and EVPN.","title":"Switch Peering Options"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#mlag","text":"The standard LACP does not support creating a bond when the links are split at one end across multiple devices. Therefore, every networking vendor has their own proprietary solution to provide that illusion. The generic name for this solution is MLAG.","title":"MLAG"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#evpn-support-for-multihoming","text":"EVPN supports dual-attached devices natively. It calls them multihomed nodes. Primarily, EVPN uses RT-1 and RT-4 message types to handle multihomed nodes. RT-1 tells the network which switches are attached to which common devices or Ethernet segments. An Ethernet segment in a data center is defined as either the bridged network to which a VTEP is connected or a bonded link. EVPN Route Types When connected to a bond, the RT-1 advertisement carries the LACP identifier of the remote node (i.e., the host in our case) as the Ethernet segment ID (ESI). When other VTEPs receive the BGP updates of this RT-1 advertisement, they can determine which of their peers are attached to the same host. RT-4 elects one of the peers as the designated forwarder for multidestination frames. The RT-4 advertisement carries the mapping of the Ethernet segment to the router servicing the segment. From all the advertisements received for an Ethernet segment, each VTEP selects the segment with the lowest VTEP IP address as the designated forwarder for a virtual network. In this case, a common VTEP IP address is not required across the two peers. Let\u2019s break this down using our sample topology. First, the standard allows leaf01 to be the designated forwarder for one set of nodes\u2014say server101 and server201\u2014and leaf02 to be the designated forwarder for another set of nodes\u2014say server102. In Pasted image 20210725123337.png , each host carries only a single VLAN. But if the hosts supported multiple VLANs, the standard further allows leaf01 to be the designated forwarder for a node \u2014say server101\u2014for one set of VLANs, and leaf02 as the designated forwarder for that node for a different set of VLANs.","title":"EVPN support for multihoming"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#handling-link-failures","text":"","title":"Handling Link failures"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#mlag_1","text":"In the case of MLAG, using the peer link to reach the host via the other switch is the most common implementation. In our example, both leaf01 and leaf02 advertise reachability to server102 via a common VTEP IP. The underlay multipaths traffic addressed to the common VTEP IP between leaf01 and leaf02. When leaf01 loses its connectivity to server102, it withdraws its advertisement of server102. However, because leaf02\u2019s advertisement is still valid, leaf03 and leaf04 see that MAC102 is still reachable via the common VTEP IP. So, a packet to server102 can still end up at leaf01, even though the link between them is down and leaf01 cannot deliver the packet directly. In such cases, leaf01 decapsulates the packet and uses the peer link to send the packet unencapsulated to leaf02, which then delivers the packet to server102.","title":"MLAG"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#evpn-multihoming","text":"In EVPN multihoming implementations, the switch that lost the connectivity to the host will also withdraw reachability to the ESI identified by the LACP of the host. This is done for both RT-1 and RT-4 routes. The other switch eventually receives these withdrawals. On receiving the RT-4 withdrawal, the remaining switch appoints itself the designated forwarder for server102. Receiving the RT-1 withdrawal tells the switch that the host is singly attached to it. The switch cannot attempt to forward the packet to its peer when it loses connectivity to the host. In our example, when leaf02 receives the withdrawal originated by leaf01, it knows that if it loses the link to server102, it cannot forward a packet to leaf01. However, reencapsulating a VXLAN packet without routing violates the split-horizon check.","title":"EVPN Multihoming"},{"location":"Network/Routing/BGP/BGP%20EVPN/EVPN%20Bridging/EVPN%20and%20Bridging/#avoiding-duplicate-multidestination-frames","text":"When the common VTEP IP model and ingress replication are used, only one of the pair of switches gets a packet. This is because the other VTEPs represent the pair with a single common VTEP IP address, and one is chosen at random to get an anycast packet. However, in the model without a shared common VTEP IP address, both switches will get a copy of multidestination frames (BUM packets, for example). To ensure that only one of the pair sends a packet to the end station, the two nodes use the RT-4 message to pick only one of them to deliver a multidestination frame in a virtual network. However, control protocol updates take time, and during the process of electing a designated forwarder or during transitions, the host can either receive no multidestination frames or receive duplicates.","title":"Avoiding Duplicate Multidestination Frames"},{"location":"Network/Virtualization/Network%20Virtualization/","text":"Network virtualization is the carving up of a single physical network into many virtual networks. Virtualizing a resource allows it to be shared by multiple users. Sharing allows the efficient use of a resource when no single user can utilize the entire resource. Virtualization affords each user the illusion that they own the resource. In the case of virtual networks, each user is under the illusion that there are no other users of the network. To preserve the illusion, virtual networks are isolated from one another. Packets cannot accidentally leak from one virtual network to another. VXLAN - General","title":"Network Virtualization"},{"location":"Network/Virtualization/VXLAN/VXLAN%20-%20General/","text":"What is VXLAN? \u2691 VXLAN (Virtual Extensible LAN) is a standard overlay protocol that abstracts logical virtual networks from the physical network underneath. You can deploy simple and scalable layer 3 Clos architectures while extending layer 2 segments over that layer 3 network. The tunnel edges are called VTEPs (VXLAN Tunnel Endpoints) VXLAN uses a VLAN-like encapsulation technique to encapsulate MAC-based layer 2 Ethernet frames within layer 3 UDP packets Each virtual network is a VXLAN logical layer 2 segment. VXLAN scales to 16 million segments - a 24-bit VXLAN network identifier (VNI ID) in the VXLAN header - for multi-tenancy. In a large VXLAN deployment, two aspects need attention: 1. discovery of other endpoints (VTEPs) sharing the same VXLAN segments 2. avoidance of BUM frames (broadcast, unknown unicast and multicast) as they have to be forwarded to all VTEPs. Each VXLAN is locally configured using a bridge for local virtual interfaces, like illustrated in the below schema. The bridge is taking care of the local MAC addresses (notably, using source-address learning) and the VXLAN interface takes care of the remote MAC addresses (received with BGP EVPN). BGP EVPN - General","title":"What is VXLAN?"},{"location":"Network/Virtualization/VXLAN/VXLAN%20-%20General/#what-is-vxlan","text":"VXLAN (Virtual Extensible LAN) is a standard overlay protocol that abstracts logical virtual networks from the physical network underneath. You can deploy simple and scalable layer 3 Clos architectures while extending layer 2 segments over that layer 3 network. The tunnel edges are called VTEPs (VXLAN Tunnel Endpoints) VXLAN uses a VLAN-like encapsulation technique to encapsulate MAC-based layer 2 Ethernet frames within layer 3 UDP packets Each virtual network is a VXLAN logical layer 2 segment. VXLAN scales to 16 million segments - a 24-bit VXLAN network identifier (VNI ID) in the VXLAN header - for multi-tenancy. In a large VXLAN deployment, two aspects need attention: 1. discovery of other endpoints (VTEPs) sharing the same VXLAN segments 2. avoidance of BUM frames (broadcast, unknown unicast and multicast) as they have to be forwarded to all VTEPs. Each VXLAN is locally configured using a bridge for local virtual interfaces, like illustrated in the below schema. The bridge is taking care of the local MAC addresses (notably, using source-address learning) and the VXLAN interface takes care of the remote MAC addresses (received with BGP EVPN). BGP EVPN - General","title":"What is VXLAN?"},{"location":"Operating-Systems/Linux/Networking/Bridge%20Interface/","text":"Create a bridge interface \u2691 With iproute2 \u2691 Create a new bridge ip link add name bridge_name type bridge Set interface to state up ip link set bridge_name up Add an interface to the bridge (state of the interface must be up) ip link set eth0 master bridge_name Verify bridge bridge link Remove interace from a bridge ip link set eth0 nomaster Internet settings \u2691 Edit file /etc/systemd/network/mybridge.network [ Match ] Name = br0 [ Network ] DHCP = ipv4 Enable, start and reload systemd-networkd sudo systemctl enable systemd-networkd sudo systemctl start systemd-networkd sudo systemctl reload systemd-networkd","title":"Create a bridge interface"},{"location":"Operating-Systems/Linux/Networking/Bridge%20Interface/#create-a-bridge-interface","text":"","title":"Create a bridge interface"},{"location":"Operating-Systems/Linux/Networking/Bridge%20Interface/#with-iproute2","text":"Create a new bridge ip link add name bridge_name type bridge Set interface to state up ip link set bridge_name up Add an interface to the bridge (state of the interface must be up) ip link set eth0 master bridge_name Verify bridge bridge link Remove interace from a bridge ip link set eth0 nomaster","title":"With iproute2"},{"location":"Operating-Systems/Linux/Networking/Bridge%20Interface/#internet-settings","text":"Edit file /etc/systemd/network/mybridge.network [ Match ] Name = br0 [ Network ] DHCP = ipv4 Enable, start and reload systemd-networkd sudo systemctl enable systemd-networkd sudo systemctl start systemd-networkd sudo systemctl reload systemd-networkd","title":"Internet settings"},{"location":"Operating-Systems/Linux/PulseAudio/Volume/","text":"Raise microphone volume with pacmd pacmd set-source-volume alsa_input.usb-Burr-Brown_from_TI_USB_Audio_CODEC-00.analog-stereo 0x25000","title":"Volume"},{"location":"Programming/Go/Formatting/","text":"Formatting in Go \u2691 The Go development tools include a command, go fmt , which automatically reformats your code to match the standard format.","title":"Formatting in Go"},{"location":"Programming/Go/Formatting/#formatting-in-go","text":"The Go development tools include a command, go fmt , which automatically reformats your code to match the standard format.","title":"Formatting in Go"},{"location":"Programming/Go/Third-Party%20Tools%20or%20Libraries/","text":"Third-Party Tools or Libraries \u2691 no central hosted service share projects via their source code repositories e.g. go install github.com/rakyll/hey@latest","title":"Third-Party Tools or Libraries"},{"location":"Programming/Go/Third-Party%20Tools%20or%20Libraries/#third-party-tools-or-libraries","text":"no central hosted service share projects via their source code repositories e.g. go install github.com/rakyll/hey@latest","title":"Third-Party Tools or Libraries"},{"location":"Programming/Python/Context%20Manager/","text":"","title":"Context Manager"},{"location":"Programming/Python/File%20IO/","text":"","title":"File IO"},{"location":"Programming/Python/Pathlib/","text":"Get current path \u2691 STATIC_FILES_DIR = Path ( __file__ ) . parent . absolute ()","title":"Get current path"},{"location":"Programming/Python/Pathlib/#get-current-path","text":"STATIC_FILES_DIR = Path ( __file__ ) . parent . absolute ()","title":"Get current path"},{"location":"Programming/Python/pytest/fixtures/","text":"parameter to fixtures \u2691 import json import pytest @pytest . fixture def json_loader (): \"\"\"Loads data from JSON file\"\"\" def _loader ( filename ): with open ( filename , 'r' ) as f : print ( filename ) data = json . load ( f ) return data return _loader def test_wrong_stop ( client , mocker , json_loader ): # Arrange get_mock = mocker . MagicMock () get_mock . status_code = 200 get_mock . json . return_value = json_loader ( cta_error_incorrect_stop_response . json ) mocker . patch . object ( backend . cta . requests , 'get' , return_value = get_mock , ) # Act response = client . simulate_get ( '/stops/106' ) # Assert assert response . status == falcon . HTTP_200 assert response . json == { 'error' : 'stop_id: 106 does not exist","title":"parameter to fixtures"},{"location":"Programming/Python/pytest/fixtures/#parameter-to-fixtures","text":"import json import pytest @pytest . fixture def json_loader (): \"\"\"Loads data from JSON file\"\"\" def _loader ( filename ): with open ( filename , 'r' ) as f : print ( filename ) data = json . load ( f ) return data return _loader def test_wrong_stop ( client , mocker , json_loader ): # Arrange get_mock = mocker . MagicMock () get_mock . status_code = 200 get_mock . json . return_value = json_loader ( cta_error_incorrect_stop_response . json ) mocker . patch . object ( backend . cta . requests , 'get' , return_value = get_mock , ) # Act response = client . simulate_get ( '/stops/106' ) # Assert assert response . status == falcon . HTTP_200 assert response . json == { 'error' : 'stop_id: 106 does not exist","title":"parameter to fixtures"},{"location":"Programming/Rust/Memory%20Management/","text":"Heat \u2691 Stack \u2691","title":"Heat"},{"location":"Programming/Rust/Memory%20Management/#heat","text":"","title":"Heat"},{"location":"Programming/Rust/Memory%20Management/#stack","text":"","title":"Stack"},{"location":"Programming/general/stack/","text":"What is a stack? \u2691 A stack is a data structure used to store a collection of objects. Individual items can be added and stored in a stack using a push operation. Objects can be retrieved using a pop operation, which removes an item from the stack. When an object is added to a stack, it is placed on the top of all previousley entered items. A stack in which items are removed from the top is conisdered a \"LIFO\" - Last in, First Out. In a \"FIFO\" - First In, First Out items are removed from the bottom.","title":"What is a stack?"},{"location":"Programming/general/stack/#what-is-a-stack","text":"A stack is a data structure used to store a collection of objects. Individual items can be added and stored in a stack using a push operation. Objects can be retrieved using a pop operation, which removes an item from the stack. When an object is added to a stack, it is placed on the top of all previousley entered items. A stack in which items are removed from the top is conisdered a \"LIFO\" - Last in, First Out. In a \"FIFO\" - First In, First Out items are removed from the bottom.","title":"What is a stack?"},{"location":"Tools/Anki/Anki-Plugins/","text":"Anki Plugins \u2691 Links \u2691","title":"Anki Plugins"},{"location":"Tools/Anki/Anki-Plugins/#anki-plugins","text":"","title":"Anki Plugins"},{"location":"Tools/Anki/Anki-Plugins/#links","text":"","title":"Links"},{"location":"Tools/Git/bfg-repo-cleaner/","text":"Clean Git Repos with BFG \u2691 Delete a filename and push changes bfg --delete-files file.md git add . git push --force","title":"Clean Git Repos with BFG"},{"location":"Tools/Git/bfg-repo-cleaner/#clean-git-repos-with-bfg","text":"Delete a filename and push changes bfg --delete-files file.md git add . git push --force","title":"Clean Git Repos with BFG"},{"location":"Tools/Vim/Comment%20out%20code/","text":"select the first character of your block press crtl + v (rectangular visual selectionn mode) type j for each line you want to be commented type shift + i (\"insert at start\") type # end with ESC","title":"Comment out code"},{"location":"Tools/Vim/copy%20all/","text":"g g \" + y G %y+","title":"Copy all"}]}